--#SET TERMINATOR @

/*
 This file is part of db2unit: A unit testing framework for Db2 LUW.
 Copyright (C)  2014  Andres Gomez Casanova (@AngocA)

 db2unit is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 db2unit is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

 Andres Gomez Casanova <angocaATyahooDOTcom>
*/

SET CURRENT SCHEMA DB2UNIT_2_BETA @

/**
 * Core implementation.
 *
 * Version: 2014-04-30 V2_BETA
 * Author: Andres Gomez Casanova (AngocA)
 * Made in COLOMBIA.
 */

/**
 * Constant for a status where there is not a test.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE NO_RESULT ANCHOR REPORT_TESTS.FINAL_STATE CONSTANT 'NoResult' @

/**
 * Constant for a unstarted test.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE RESULT_UNSTARTED ANCHOR REPORT_TESTS.FINAL_STATE CONSTANT 'Unstarted' @

/**
 * Constant for a executing test.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE EXECUTING ANCHOR REPORT_TESTS.FINAL_STATE CONSTANT 'Executing' @

/**
 * Constant for a passed test.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE RESULT_PASSED ANCHOR REPORT_TESTS.FINAL_STATE CONSTANT 'Passed' @

/**
 * Constant for a passed test.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE RESULT_FAILED ANCHOR REPORT_TESTS.FINAL_STATE CONSTANT 'Failed' @

/**
 * Constant for a passed test.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE RESULT_ERROR ANCHOR REPORT_TESTS.FINAL_STATE CONSTANT 'Error' @

/**
 * Constant for a unknown state test.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE RESULT_UNKNOWN ANCHOR REPORT_TESTS.FINAL_STATE CONSTANT 'Unknown' @

/**
 * Constant for OneTimeSetup.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE ONE_TIME_SETUP VARCHAR(20) CONSTANT 'ONE_TIME_SETUP' @

/**
 * Undefined execution id.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE UNDEF_EXEC_ID ANCHOR EXECUTIONS.EXECUTION_ID CONSTANT -1 @

/**
 * Constant for OneTimeSetup.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE SETUP VARCHAR(20) CONSTANT 'SETUP' @

/**
 * Constant for OneTimeSetup.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE TEAR_DOWN VARCHAR(20) CONSTANT 'TEAR_DOWN' @

/**
 * Constant for OneTimeSetup.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE ONE_TIME_TEAR_DOWN VARCHAR(20) CONSTANT 'ONE_TIME_TEAR_DOWN' @

/**
 * Maximal size for assertion messages.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE MAX_MESSAGE SMALLINT CONSTANT 400 @

/**
 * Unique seed for all executions to generate unique values.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE SEED BIGINT DEFAULT NULL @

/**
 * ID of the current execution.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE EXEC_ID ANCHOR EXECUTIONS.EXECUTION_ID @

/**
 * ID of the current execution. Copy for other wrapped SP.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE EXEC_ID_COPY ANCHOR EXECUTIONS.EXECUTION_ID @

/**
 * ID of the most recent execution in the current session.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE LAST_EXEC_ID ANCHOR EXECUTIONS.EXECUTION_ID @

/**
 * Current schema being tested.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE CUR_SCHEMA ANCHOR SYSCAT.SCHEMATA.SCHEMANAME @

/**
 * Name of the most recent executed schema.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE LAST_SCHEMA ANCHOR SYSCAT.SCHEMATA.SCHEMANAME @

/**
 * Current test being executed.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE TESTNAME ANCHOR SYSCAT.PROCEDURES.PROCNAME @

/**
 * Returned status after the execution.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE TEST_RESULT ANCHOR REPORT_TESTS.FINAL_STATE DEFAULT NO_RESULT @

/**
 * Previous returned status after the execution.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE PREVIOUS_TEST_RESULT ANCHOR REPORT_TESTS.FINAL_STATE
  DEFAULT NO_RESULT @

/**
 * Description of current test. This variable is useful when no assertions are
 * called, but the test fails. It is only used when an exception is caught.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE TEST_MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT DEFAULT NULL @

-- Transaction mode execution.
ALTER MODULE DB2UNIT ADD
  VARIABLE AUTONOMOUS_EXEC BOOLEAN DEFAULT TRUE @

/**
 * Order type to sort the procedures names. False ordered by name; true random.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE RANDOM_SORT BOOLEAN DEFAULT TRUE @

/**
 * Array of procedure's names.
 */
ALTER MODULE DB2UNIT ADD
  TYPE PROCS_NAMES_TYPE AS ANCHOR SYSCAT.PROCEDURES.PROCNAME ARRAY [] @

/**
 * List of procedure.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE PROCS_NAMES PROCS_NAMES_TYPE @

/**
 * Function that escape the single quotes by replacing them with two single
 * quotes.
 *
 * IN MSG
 *   Message to analyse.
 * RETURNS Same message with single quotes escaped.
 */
ALTER MODULE DB2UNIT ADD
  FUNCTION ESCAPE_QUOTES (
  IN MSG ANCHOR REPORT_TESTS.MESSAGE
  ) RETURNS ANCHOR REPORT_TESTS.MESSAGE
  LANGUAGE SQL
  READS SQL DATA
  DETERMINISTIC
  SPECIFIC F_ESCAPE_QUOTES
  NO EXTERNAL ACTION
 F_ESCAPE_QUOTES : BEGIN
  DECLARE LENGTH SMALLINT;
  DECLARE INDEX SMALLINT;
  DECLARE PRE ANCHOR REPORT_TESTS.MESSAGE;
  DECLARE RET ANCHOR REPORT_TESTS.MESSAGE;

  SET LENGTH = LENGTH(MSG);
  SET INDEX = 0;
  SET RET = '';
  WHILE (INDEX < LENGTH) DO
   SET INDEX = POSSTR(MSG, '''');
   IF (INDEX <> 0) THEN
    SET PRE = SUBSTR(MSG, 1, INDEX - 1);
    SET RET = RET || PRE || '''''';
    SET MSG = SUBSTR(MSG, INDEX + 1);
    SET INDEX = 0;
    SET LENGTH = LENGTH(MSG);
   ELSE
    SET INDEX = LENGTH;
    SET RET = RET || MSG;
   END IF;
  END WHILE;
  RETURN RET;
 END F_ESCAPE_QUOTES @

/**
 * Write a message in the tests' report. Implementation.
 *
 * IN MSG
 *   Message to insert in the report.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE WRITE_IN_REPORT_BODY (
  IN MSG ANCHOR REPORT_TESTS.MESSAGE
  )
  LANGUAGE SQL
  SPECIFIC P_WRITE_IN_REPORT_BODY
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_WRITE_IN_REPORT_BODY: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  -- To keep the generated error.
  DECLARE SQLCODE INTEGER DEFAULT 0;
  DECLARE SQLSTATE CHAR(5) DEFAULT '00000';

  DECLARE MSG_TEXT ANCHOR MAX_SIGNAL.SIGNAL; -- Message from signal.
  DECLARE SENTENCE ANCHOR MAX_VALUES.SENTENCE; -- Dynamic statement
    -- to execute.
  DECLARE STMT STATEMENT; -- Statement to execute.

  DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
     DECLARE COPY_SQLSTATE CHAR(5);
     DECLARE COPY_SQLCODE INTEGER;
     GET DIAGNOSTICS EXCEPTION 1 MSG_TEXT = MESSAGE_TEXT;
     SET COPY_SQLSTATE = SQLSTATE, COPY_SQLCODE = SQLCODE;
     IF (EXEC_ID IS NULL) THEN
      SET EXEC_ID = UNDEF_EXEC_ID;
     END IF;
     INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
       VALUES (CURRENT TIMESTAMP, EXEC_ID, '', SUBSTR('Exception(1): SQLCode '
       || COALESCE(COPY_SQLCODE, -1) || ', SQLState ' || COALESCE(COPY_SQLSTATE,
       'EMPTY') || ', Message: ' || MSG_TEXT, 1, 256));
     CALL LOGGER.INFO(LOGGER_ID, '< With exception(1) '
       || COALESCE(COPY_SQLSTATE, 'EMPTY') || '-'
       || COALESCE(COPY_SQLCODE, -1));
     COMMIT;
    END;

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.WRITE_IN_REPORT_BODY', LOGGER_ID);

  SET MSG = TRIM(MSG);
  CALL LOGGER.INFO(LOGGER_ID, '>' || COALESCE(MSG, ''));
  CALL LOGGER.DEBUG(LOGGER_ID, 'Schema ' || COALESCE(CUR_SCHEMA, 'NoSchema'));
  CALL LOGGER.DEBUG(LOGGER_ID, 'Report ' || COALESCE(REPORTS_TABLE, 'NoTable'));
  CALL LOGGER.DEBUG(LOGGER_ID, 'ExecId ' || COALESCE(EXEC_ID, 'NoExecId'));
  CALL LOGGER.DEBUG(LOGGER_ID, 'TestName ' || COALESCE(TESTNAME, 'NoTestName'));
  CALL LOGGER.DEBUG(LOGGER_ID, 'Message "' || COALESCE(MSG, 'NoMsg') || '"');

  IF (CUR_SCHEMA IS NULL OR REPORTS_TABLE IS NULL) THEN
   IF (EXEC_ID IS NULL) THEN
    SET EXEC_ID = UNDEF_EXEC_ID;
    SET EXEC_ID_COPY = EXEC_ID;
   END IF;
   CALL LOGGER.DEBUG(LOGGER_ID, 'Not in a test suite: ' || SUBSTR(MSG, 1, 500));
   INSERT INTO TEMP_REPORT_TESTS (MESSAGE) VALUES (COALESCE(MSG, 'NULL'));
  ELSE
   SET MSG = ESCAPE_QUOTES(MSG);
   SET SENTENCE = 'INSERT INTO ' || CUR_SCHEMA || '.' || REPORTS_TABLE
     || ' (DATE, EXECUTION_ID, TEST_NAME, MESSAGE) VALUES ('
     || 'CURRENT TIMESTAMP, ' || COALESCE(EXEC_ID, UNDEF_EXEC_ID) || ', '''
     || COALESCE(TESTNAME, '') || ''', ''' || COALESCE(MSG, 'NULL') || ''')';
   CALL LOGGER.DEBUG(LOGGER_ID, 'Sentence: ' || SENTENCE);
   PREPARE STMT FROM SENTENCE;
   EXECUTE STMT;
  END IF;

  COMMIT;

  CALL LOGGER.INFO(LOGGER_ID, '<');
 END P_WRITE_IN_REPORT_BODY @

/**
 * Write a message in the tests' report. Autonomous.
 *
 * IN MSG
 *   Message to insert in the report.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE WRITE_IN_REPORT_AUTONOMOUS (
  IN MSG ANCHOR REPORT_TESTS.MESSAGE
  )
  LANGUAGE SQL
  SPECIFIC P_WRITE_IN_REPORT_AUTONOMOUS
  DYNAMIC RESULT SETS 0
  AUTONOMOUS -- Autonomous transactions, it means it writes anyway.
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_WRITE_IN_REPORT_AUTONOMOUS: BEGIN
  DECLARE LOGGER_ID SMALLINT;

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.WRITE_IN_REPORT_AUTONOMOUS',
    LOGGER_ID);

  CALL LOGGER.INFO(LOGGER_ID, 'It got into an autonomous transaction');

  CALL WRITE_IN_REPORT_BODY(MSG);
 END P_WRITE_IN_REPORT_AUTONOMOUS @

/**
 * Write a message in the tests' report. Dispatcher between autonomous or not.
 *
 * IN MSG
 *   Message to insert in the report.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE WRITE_IN_REPORT (
  IN MSG ANCHOR REPORT_TESTS.MESSAGE
  )
  LANGUAGE SQL
  SPECIFIC P_WRITE_IN_REPORT
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_WRITE_IN_REPORT: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE AUTONOMOUS_ERROR CONDITION FOR SQLSTATE '560D2';
  DECLARE CONTINUE HANDLER FOR AUTONOMOUS_ERROR
    BEGIN
     INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
       VALUES (CURRENT TIMESTAMP, EXEC_ID, -2, 'Autonomous error in '
       || 'WRITE_IN_REPORT');
     CALL LOGGER.FATAL(LOGGER_ID, 'Autonomous error in WRITE_IN_REPORT');
    END;

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.WRITE_IN_REPORT', LOGGER_ID);

  IF (AUTONOMOUS_EXEC = TRUE AND CUR_SCHEMA IS NOT NULL
    AND REPORTS_TABLE IS NOT NULL) THEN
   CALL LOGGER.INFO(LOGGER_ID, 'It will get into an autonomous transaction');
   CALL WRITE_IN_REPORT_AUTONOMOUS(MSG);
  ELSE
   CALL WRITE_IN_REPORT_BODY(MSG);
  END IF;
 END P_WRITE_IN_REPORT @

/**
 * Sorts the procedures list.
 *
 * IN PREV_EXEC_ID
 *   Previous execution ID to run the tests in that same order. Useful when
 *   tests were executed randomly and generate an error.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE SORT_PROC_NAMES (
  IN PREV_EXEC_ID ANCHOR EXECUTIONS.EXECUTION_ID DEFAULT NULL
  )
  LANGUAGE SQL
  SPECIFIC P_SORT_PROC_NAMES
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_SORT_PROC_NAMES: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE NEW_LIST PROCS_NAMES_TYPE;
  DECLARE INDEX INT;
  DECLARE LENGTH SMALLINT;
  DECLARE POS INT;
  DECLARE PROC_NAME ANCHOR SYSCAT.PROCEDURES.PROCNAME;

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.SORT_PROC_NAMES', LOGGER_ID);
  CALL LOGGER.INFO(LOGGER_ID, '>');

  IF (PREV_EXEC_ID IS NULL AND RANDOM_SORT = FALSE) THEN
   CALL LOGGER.INFO(LOGGER_ID, 'No random');
  ELSEIF (PREV_EXEC_ID IS NULL AND RANDOM_SORT = TRUE) THEN
   CALL LOGGER.INFO(LOGGER_ID, 'Random');
   SET INDEX = 1;
   SET LENGTH = CARDINALITY(PROCS_NAMES);
   WHILE (INDEX <= LENGTH) DO
    -- Looks for an empty space
    BEGIN
     DECLARE ARRAY_ERROR CONDITION FOR SQLSTATE '2202E';
     DECLARE EXIT HANDLER FOR ARRAY_ERROR SET PROC_NAME = NULL;
     SET POS = RAND() * LENGTH + 1;
     SET PROC_NAME = NEW_LIST[POS];
     WHILE (PROC_NAME IS NOT NULL) DO
      CALL LOGGER.DEBUG(LOGGER_ID, 'Try ' || POS);
      SET POS = RAND() * LENGTH + 1;
      SET PROC_NAME = NEW_LIST[POS];
     END WHILE;
    END;
    CALL LOGGER.DEBUG(LOGGER_ID, 'Iteration ' || INDEX || ' position ' || POS);

    SET NEW_LIST[POS] = PROCS_NAMES[INDEX];
    SET INDEX = INDEX + 1;
   END WHILE;
   SET PROCS_NAMES = NEW_LIST;
  ELSE
   SET PROCS_NAMES = (
     SELECT ARRAY_AGG(TEST_NAME ORDER BY POSITION)
     FROM SORTS
     WHERE SUITE_NAME = CUR_SCHEMA
     AND EXECUTION_ID = PREV_EXEC_ID);
   CALL LOGGER.DEBUG(LOGGER_ID, 'Elements ' || CARDINALITY(PROCS_NAMES));
  END IF;

  CALL LOGGER.INFO(LOGGER_ID, '<' );
 END P_SORT_PROC_NAMES @

/**
 * Writes the order of the list in a table for future reference.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE SAVE_LIST (
  )
  LANGUAGE SQL
  SPECIFIC P_SAVE_LIST
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_SAVE_LIST: BEGIN
  INSERT INTO SORTS
    SELECT CUR_SCHEMA, EXEC_ID, POSITION, TEST_NAME
    FROM UNNEST(PROCS_NAMES) WITH ORDINALITY AS (TEST_NAME, POSITION);
 END P_SAVE_LIST @

/**
 * Register the message of a test. Useful when a test is executed without
 * calling assertion, but it fails anyway.
 *
 * IN MESSAGE
 *   Related message to the test.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE REGISTER_MESSAGE(
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT
  )
  LANGUAGE SQL
  SPECIFIC P_REGISTER_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_REGISTER_MESSAGE: BEGIN
  IF (MESSAGE IS NULL) THEN
   SET TEST_MESSAGE = '';
  ELSE
   SET TEST_MESSAGE = MESSAGE;
  END IF;
 END P_REGISTER_MESSAGE @

/**
 * Execute a procedure without parameters. Implementation.
 *
 * IN PROC_NAME
 *   Name of the stored procedure.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE EXEC_PROCEDURE_BODY (
  IN PROC_NAME ANCHOR SYSCAT.PROCEDURES.PROCNAME,
  OUT CONT BOOLEAN
  )
  LANGUAGE SQL
  SPECIFIC P_EXEC_PROCEDURE_BODY
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_EXEC_PROCEDURE_BODY: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  -- To keep the generated error.
  DECLARE SQLCODE INTEGER DEFAULT 0;
  DECLARE SQLSTATE CHAR(5) DEFAULT '00000';

  DECLARE MSG_TEXT ANCHOR MAX_SIGNAL.SIGNAL; -- Message from signal.
  DECLARE SENTENCE ANCHOR MAX_VALUES.SENTENCE; -- Dynamic statement
    -- to execute.
  DECLARE INEXISTENT CONDITION FOR SQLSTATE '42884';
  DECLARE TOO_LONG CONDITION FOR SQLSTATE '22001';
  DECLARE STMT STATEMENT; -- Statement to execute.
  -- If the procedure does not exist, then exist without any message.
  DECLARE EXIT HANDLER FOR INEXISTENT
    BEGIN
     SET CONT = TRUE;
     CALL LOGGER.INFO(LOGGER_ID, '<');
    END;
  -- A string is too long to be processed.
  DECLARE EXIT HANDLER FOR TOO_LONG
    BEGIN
     DECLARE COPY_SQLSTATE CHAR(5);
     GET DIAGNOSTICS EXCEPTION 1 MSG_TEXT = MESSAGE_TEXT;
     SET COPY_SQLSTATE = SQLSTATE;
     CALL WRITE_IN_REPORT(SUBSTR('String too long: "' || COALESCE(MSG_TEXT,
       'No message') || '"', 1, 512));
     CALL LOGGER.INFO(LOGGER_ID, '< String too long ' || COALESCE(COPY_SQLSTATE,
       'EMPTY') || '-' || COALESCE(MSG_TEXT, 'No message'));
     SET CONT = TRUE;
     COMMIT;
    END;
  -- Logs any exception or warning.
  DECLARE EXIT HANDLER FOR SQLWARNING
    BEGIN
     DECLARE COPY_SQLSTATE CHAR(5);
     DECLARE COPY_SQLCODE INTEGER;
     GET DIAGNOSTICS EXCEPTION 1 MSG_TEXT = MESSAGE_TEXT;
     SET COPY_SQLSTATE = SQLSTATE, COPY_SQLCODE = SQLCODE;
     CALL WRITE_IN_REPORT(TEST_MESSAGE);
     CALL WRITE_IN_REPORT(SUBSTR('Warning(2): SQLCode' || COALESCE(COPY_SQLCODE,
       -1) || '-SQLState' || COALESCE(COPY_SQLSTATE, 'EMPTY') || '-'
       || COALESCE(MSG_TEXT, 'No message'), 1, 512));
     CALL LOGGER.INFO(LOGGER_ID, '< With warning(2) ' || COALESCE(COPY_SQLSTATE,
       'EMPTY') || '-' || COALESCE(COPY_SQLCODE, -1) || TEST_MESSAGE);
     SET CONT = TRUE;
     COMMIT;
    END;
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
     DECLARE COPY_SQLSTATE CHAR(5);
     DECLARE COPY_SQLCODE INTEGER;
     GET DIAGNOSTICS EXCEPTION 1 MSG_TEXT = MESSAGE_TEXT;
     SET COPY_SQLSTATE = SQLSTATE, COPY_SQLCODE = SQLCODE;
     CALL WRITE_IN_REPORT(TEST_MESSAGE);
     CALL WRITE_IN_REPORT(SUBSTR('Exception(2): SQLCode ' || COALESCE(
       COPY_SQLCODE, -1) || ', SQLState ' || COALESCE(COPY_SQLSTATE, 'EMPTY')
       || '-' || COALESCE(MSG_TEXT, 'No message'), 1, 512));
     CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.EXEC_PROCEDURE_BODY', LOGGER_ID);
     CALL LOGGER.INFO(LOGGER_ID, '< With exception(2) '
       || COALESCE(COPY_SQLSTATE, 'EMPTY') || '-'
       || COALESCE(COPY_SQLCODE, -1) || TEST_MESSAGE);
     IF (TEST_RESULT = EXECUTING) THEN
      SET TEST_RESULT = RESULT_ERROR;
     END IF;
     SET CONT = FALSE;
     COMMIT;
    END;

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.EXEC_PROCEDURE_BODY', LOGGER_ID);
  CALL LOGGER.INFO(LOGGER_ID, '>' || COALESCE(PROC_NAME, 'NoName'));

  IF (PROC_NAME IS NOT NULL) THEN
   SET SENTENCE = 'CALL ' || CUR_SCHEMA || '.' || PROC_NAME || '()';
   CALL LOGGER.DEBUG(LOGGER_ID, 'Sentence: ' || SENTENCE);
   PREPARE STMT FROM SENTENCE;
   EXECUTE STMT;
  ELSE
   CALL LOGGER.ERROR(LOGGER_ID, 'Null procedure name');
  END IF;

  SET CONT = TRUE;

  CALL LOGGER.INFO(LOGGER_ID, '<');
  COMMIT;
 END P_EXEC_PROCEDURE_BODY @

/**
 * Execute a procedure without parameters. Autonomous.
 *
 * IN PROC_NAME
 *   Name of the stored procedure.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE EXEC_PROCEDURE_AUTONOMOUS (
  IN PROC_NAME ANCHOR SYSCAT.PROCEDURES.PROCNAME,
  OUT CONT BOOLEAN
  )
  LANGUAGE SQL
  SPECIFIC P_EXEC_PROCEDURE_AUTONOMOUS
  DYNAMIC RESULT SETS 0
  AUTONOMOUS -- Autonomous transactions, it means it writes anyway.
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_EXEC_PROCEDURE_AUTONOMOUS: BEGIN
  DECLARE LOGGER_ID SMALLINT;

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.EXEC_PROCEDURE_AUTONOMOUS',
    LOGGER_ID);

  CALL LOGGER.INFO(LOGGER_ID, 'It got into an autonomous transaction for '
    || COALESCE(PROC_NAME, '?'));

  CALL EXEC_PROCEDURE_BODY(PROC_NAME, CONT);
 END P_EXEC_PROCEDURE_AUTONOMOUS @

/**
 * Execute a procedure without parameters. Dispatcher between autonomous or not.
 *
 * IN PROC_NAME
 *   Name of the stored procedure.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE EXEC_PROCEDURE (
  IN PROC_NAME ANCHOR SYSCAT.PROCEDURES.PROCNAME,
  OUT CONT BOOLEAN
  )
  LANGUAGE SQL
  SPECIFIC P_EXEC_PROCEDURE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_EXEC_PROCEDURE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE AUTONOMOUS_ERROR CONDITION FOR SQLSTATE '560D2';
  DECLARE CONTINUE HANDLER FOR AUTONOMOUS_ERROR
    BEGIN
     INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
       VALUES (CURRENT TIMESTAMP, EXEC_ID, -3, 'Autonomous error in '
       || 'EXEC_PROCEDURE');
     CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.EXEC_PROCEDURE', LOGGER_ID);
     CALL LOGGER.FATAL(LOGGER_ID, 'Autonomous error in EXEC_PROCEDURE for '
       || COALESCE(PROC_NAME, '?'));
     SET CONT = FALSE;
    END;

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.EXEC_PROCEDURE', LOGGER_ID);

  IF (AUTONOMOUS_EXEC = TRUE) THEN
   CALL LOGGER.INFO(LOGGER_ID, 'It will get into an autonomous transaction for '
     || COALESCE(PROC_NAME, '?'));
   CALL EXEC_PROCEDURE_AUTONOMOUS(PROC_NAME, CONT);
  ELSE
   CALL EXEC_PROCEDURE_BODY(PROC_NAME, CONT);
  END IF;
 END P_EXEC_PROCEDURE @

/**
 * Performs the execution of the tests.
 *
 * INOUT CURRENT_STATUS
 *   Current status of the global execution.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE EXECUTION (
  INOUT CURRENT_STATUS ANCHOR EXECUTION_REPORTS.STATUS
  )
  LANGUAGE SQL
  SPECIFIC P_EXECUTION
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_EXECUTION: BEGIN
  -- To keep the generated error.
  DECLARE SQLCODE INTEGER DEFAULT 0;
  DECLARE SQLSTATE CHAR(5) DEFAULT '00000';

  DECLARE LOGGER_ID SMALLINT;
  DECLARE CARD_PROCS INT; -- Quantity of procedures.
  DECLARE INDEX INT; -- Index to scan the procedures.
  DECLARE START_TIME TIMESTAMP; -- Start time of the execution.
  DECLARE SECONDS ANCHOR REPORT_TESTS.TIME; -- To count the expended
    -- time.
  DECLARE SENTENCE ANCHOR MAX_VALUES.SENTENCE; -- Dynamic statement
    -- to execute.

  DECLARE CONT_BEFORE_ALL BOOLEAN DEFAULT FALSE;
  DECLARE CONT_BEFORE BOOLEAN DEFAULT FALSE;

  -- For tests summary
  DECLARE TESTS_EXEC SMALLINT DEFAULT 0;
  DECLARE TESTS_PASSED SMALLINT DEFAULT 0;
  DECLARE TESTS_FAILED SMALLINT DEFAULT 0;
  DECLARE TESTS_ERROR SMALLINT DEFAULT 0;
  DECLARE TESTS_UNSTARTED SMALLINT DEFAULT 0;
  DECLARE RET INTEGER DEFAULT 0;
  DECLARE DATETIME_OVERFLOW CONDITION FOR SQLSTATE '22008';

  DECLARE STMT STATEMENT; -- Statement to execute.

  -- When the milliseconds conversion cannot be made.
  DECLARE CONTINUE HANDLER FOR DATETIME_OVERFLOW
    BEGIN
     SET SENTENCE = 'UPDATE ' || CUR_SCHEMA || '.' || REPORTS_TABLE || ' '
       || 'SET TIME = -1 '
       || 'WHERE MESSAGE = ''Executing ' || COALESCE(TESTNAME, 'NULL') || ''' '
       || 'AND EXECUTION_ID = ' || EXEC_ID;
     PREPARE STMT FROM SENTENCE;
     EXECUTE STMT;
    END;
  DECLARE CONTINUE HANDLER FOR SQLWARNING
    BEGIN
     DECLARE COPY_SQLSTATE CHAR(5);
     DECLARE COPY_SQLCODE INTEGER;
     SET COPY_SQLSTATE = SQLSTATE, COPY_SQLCODE = SQLCODE;
     INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
       VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS, 'Warning(3): SQLCode '
       || COALESCE(COPY_SQLCODE, -1) || ', SQLState ' || COALESCE(COPY_SQLSTATE,
       'EMPTY'));
     CALL LOGGER.INFO(LOGGER_ID, 'Warning(3) ' || COALESCE(COPY_SQLSTATE,
       'EMPTY') || '-' || COALESCE(COPY_SQLCODE, -1));
    END;
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
     DECLARE COPY_SQLSTATE CHAR(5);
     DECLARE COPY_SQLCODE INTEGER;
     SET COPY_SQLSTATE = SQLSTATE, COPY_SQLCODE = SQLCODE;
     INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
       VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS,
       'Exception(3): SQLCode ' || COALESCE(COPY_SQLCODE, -1) || ', SQLState '
       || COALESCE(COPY_SQLSTATE, 'EMPTY') || COALESCE(':' || TESTNAME, ''));
     CALL LOGGER.INFO(LOGGER_ID, 'Exception(3) ' || COALESCE(COPY_SQLSTATE,
       'EMPTY') || '-' || COALESCE(COPY_SQLCODE, -1) || COALESCE(':'
       || TESTNAME, ''));
     SET CONT_BEFORE_ALL = FALSE;
     SET CONT_BEFORE = FALSE;
    END;

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.EXECUTION', LOGGER_ID);
  CALL LOGGER.WARN(LOGGER_ID, '>');

  COMMIT;

  -- BEFORE SUITE
  SET CURRENT_STATUS = 'Executing.BeforeSuite';
  CALL LOGGER.INFO(LOGGER_ID, CURRENT_STATUS);
  SET TESTNAME = 'Before Suite';
  CALL WRITE_IN_REPORT('Starting execution');
  SET CONT_BEFORE_ALL = TRUE;
  CALL EXEC_PROCEDURE(ONE_TIME_SETUP, CONT_BEFORE_ALL);
  COMMIT;

  SET CARD_PROCS = CARDINALITY(PROCS_NAMES);
  IF (CONT_BEFORE_ALL = TRUE) THEN
   SET INDEX = 1;
   WHILE (INDEX <= CARD_PROCS) DO

    -- BEFORE
    SET CONT_BEFORE = TRUE;
    SET TEST_RESULT = RESULT_UNSTARTED;
    SET CURRENT_STATUS = 'Executing.Before';
    -- When testing log4db2, the id could be deleted.
    CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.EXECUTION', LOGGER_ID);
    CALL LOGGER.INFO(LOGGER_ID, CURRENT_STATUS);
    SET TESTNAME = PROCS_NAMES[INDEX];
    CALL WRITE_IN_REPORT(SUBSTR('Executing ' || COALESCE(TESTNAME, 'NULL'), 1,
      128));
    CALL EXEC_PROCEDURE(SETUP, CONT_BEFORE);
    COMMIT;

    SET SECONDS = -1;
    -- TEST
    IF (CONT_BEFORE = TRUE) THEN
     SET CURRENT_STATUS = 'Executing.Test';
     -- When testing log4db2, the id could be deleted.
     CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.EXECUTION', LOGGER_ID);
     CALL LOGGER.INFO(LOGGER_ID, CURRENT_STATUS);
     SET START_TIME = CURRENT TIMESTAMP;
     SET TEST_RESULT = EXECUTING;
     CALL EXEC_PROCEDURE(TESTNAME, CONT_BEFORE);
     SET SECONDS = TIMESTAMPDIFF(1, CURRENT TIMESTAMP - START_TIME);
     COMMIT;
    END IF;

    IF (TEST_RESULT = EXECUTING) THEN
     SET TEST_RESULT = RESULT_PASSED;
    ELSEIF (TEST_RESULT IS NULL) THEN
     SET TEST_RESULT = RESULT_UNKNOWN;
    END IF;
    -- Update the statistics
    SET TESTS_EXEC = TESTS_EXEC + 1;
    IF (TEST_RESULT = RESULT_PASSED) THEN
     SET TESTS_PASSED = TESTS_PASSED + 1;
    ELSEIF (TEST_RESULT = RESULT_FAILED) THEN
     SET TESTS_FAILED = TESTS_FAILED + 1;
    ELSEIF (TEST_RESULT = RESULT_ERROR) THEN
     SET TESTS_ERROR = TESTS_ERROR + 1;
    ELSEIF (TEST_RESULT = RESULT_UNSTARTED) THEN
     SET TESTS_UNSTARTED = TESTS_UNSTARTED + 1;
    END IF;

   -- Insert result
    CALL LOGGER.DEBUG(LOGGER_ID, CUR_SCHEMA || ':' || EXEC_ID || ':'
      || TESTNAME || '=' || TEST_RESULT);
    INSERT INTO RESULT_TESTS (SUITE_NAME, EXECUTION_ID, TEST_NAME, FINAL_STATE,
      DATE, DURATION) VALUES (CUR_SCHEMA, EXEC_ID, TESTNAME, TEST_RESULT,
      CURRENT TIMESTAMP, SECONDS);

    -- Insert report
    SET SENTENCE = 'UPDATE ' || CUR_SCHEMA || '.' || REPORTS_TABLE || ' '
      || 'SET TIME = ' || SECONDS || ', '
      || 'FINAL_STATE = ''' || TEST_RESULT || ''' '
      || 'WHERE MESSAGE = ''Executing ' || COALESCE(TESTNAME, 'NULL') || ''' '
      || 'AND EXECUTION_ID = ' || EXEC_ID;
    SET TEST_RESULT = NO_RESULT;
    SET TEST_MESSAGE = NULL;
    PREPARE STMT FROM SENTENCE;
    EXECUTE STMT;
    COMMIT;

    -- AFTER
    SET CURRENT_STATUS = 'Executing.After';
    -- When testing log4db2, the id could be deleted.
    CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.EXECUTION', LOGGER_ID);
    CALL LOGGER.INFO(LOGGER_ID, CURRENT_STATUS);
    CALL EXEC_PROCEDURE(TEAR_DOWN, CONT_BEFORE);
    SET TESTNAME = NULL;
    COMMIT;

    SET INDEX = INDEX + 1;
   END WHILE;
  END IF;

  -- AFTER SUITE
  SET CURRENT_STATUS = 'Executing.AfterSuite';
  SET TESTNAME = 'After Suite';
  -- When testing log4db2, the id could be deleted.
  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.EXECUTION', LOGGER_ID);
  CALL LOGGER.INFO(LOGGER_ID, CURRENT_STATUS);
  CALL EXEC_PROCEDURE(ONE_TIME_TEAR_DOWN, CONT_BEFORE);
  CALL WRITE_IN_REPORT('Finishing execution');
  SET TESTNAME = NULL;
  COMMIT;

 -- Write a summary
  CALL WRITE_IN_REPORT (TESTS_EXEC || ' tests were executed');
  CALL WRITE_IN_REPORT (TESTS_PASSED || ' tests passed');
  CALL WRITE_IN_REPORT (TESTS_FAILED || ' tests failed');
  CALL WRITE_IN_REPORT (TESTS_ERROR || ' tests with errors');
  CALL WRITE_IN_REPORT (TESTS_UNSTARTED || ' unexecuted tests');

  -- Updates the suite execution
  UPDATE SUITES_EXECUTIONS SET
    TOTAL_TESTS = TESTS_EXEC,
    PASSED_TESTS = TESTS_PASSED,
    FAILED_TESTS = TESTS_FAILED,
    ERROR_TESTS = TESTS_ERROR,
    UNEXEC_TESTS = TESTS_UNSTARTED
    WHERE EXECUTION_ID = EXEC_ID
    AND SUITE_NAME = CUR_SCHEMA;

  -- Return value
  IF (TESTS_ERROR > 0 OR TESTS_FAILED > 0) THEN
   SET RET = 1;
  END IF;

  -- When testing log4db2, the id could be deleted.
  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.EXECUTION', LOGGER_ID);
  CALL LOGGER.WARN(LOGGER_ID, '<');

  RETURN RET;
 END P_EXECUTION @

/**
 * Process the name of a schema, by adding extra spaces when the size is less
 * than 8.
 *
 * IN SCHEMA_NAME
 *   Name of the schema to process.
 * RETURN the same name of the schema with extra space in order to be at least
 *   8 chars length.
 */
ALTER MODULE DB2UNIT ADD
  FUNCTION PROCESS_SCHEMA (
  IN SCHEMA_NAME ANCHOR SYSCAT.SCHEMATA.SCHEMANAME
  ) RETURNS ANCHOR SYSCAT.SCHEMATA.SCHEMANAME
  LANGUAGE SQL
  READS SQL DATA
  DETERMINISTIC
  SPECIFIC F_PROCESS_SCHEMA
  NO EXTERNAL ACTION
 F_PROCESS_SCHEMA : BEGIN
  DECLARE SIZE SMALLINT;
  SET SIZE = LENGTH(SCHEMA_NAME);
  WHILE (SIZE < 8) DO
   SET SCHEMA_NAME = SCHEMA_NAME || ' ';
   SET SIZE = LENGTH(SCHEMA_NAME);
  END WHILE;
  RETURN SCHEMA_NAME;
 END F_PROCESS_SCHEMA @

/**
 * Returns a random number for the execution ID.
 *
 * RETURN a unique number for the execution ID.
 */
ALTER MODULE DB2UNIT ADD
  FUNCTION GET_RANDOM_ID (
  ) RETURNS ANCHOR EXECUTIONS.EXECUTION_ID
  LANGUAGE SQL
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  SPECIFIC F_GET_RANDOM_ID
  NO EXTERNAL ACTION
 F_GET_RANDOM_ID : BEGIN
  DECLARE TIME TIMESTAMP;
  DECLARE IGNORED DOUBLE;
  DECLARE RET ANCHOR EXECUTIONS.EXECUTION_ID;
  DECLARE RETRY BOOLEAN DEFAULT TRUE;
  DECLARE APP_ID BIGINT;

  DECLARE LOGGER_ID SMALLINT;

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.GET_RANDOM_ID', LOGGER_ID);
  CALL LOGGER.WARN(LOGGER_ID, '>');

  IF (SEED IS NULL) THEN
   SET TIME = CURRENT_TIMESTAMP;
   SET APP_ID = (SELECT APPLICATION_HANDLE
     FROM SYSIBMADM.MON_CONNECTION_SUMMARY
     WHERE APPLICATION_ID = APPLICATION_ID());
   SET SEED = (BIGINT((APP_ID * 10000000000 + MINUTE(TIME)) * 60
      + SECOND(TIME) * 1000000 + MICROSECOND(time)));
   SET IGNORED = RAND(INTEGER(MOD(SEED, 2147483648)));
   CALL LOGGER.DEBUG(LOGGER_ID, 'seed' || SEED);
  END IF;

  WHILE (RETRY = TRUE) DO
   SET RET = RAND() * 100000;
   CALL LOGGER.WARN(LOGGER_ID, 'Value ' || RET);
   BEGIN
    DECLARE EXISTING_ID CONDITION FOR SQLSTATE '23505';
    DECLARE EXIT HANDLER FOR EXISTING_ID
      SET RETRY = TRUE;
     INSERT INTO EXECUTIONS (EXECUTION_ID) VALUES (RET);
    SET RETRY = FALSE;
   END;
  END WHILE;

  CALL LOGGER.WARN(LOGGER_ID, '<');

  RETURN RET;
 END F_GET_RANDOM_ID @

/**
 * Execute the tests defined in a set of stored procedure in the given schema.
 * PREV_EXEC_ID and TEST_NAME cannot be passed at the same time.
 *
 * IN SCHEMA_NAME
 *   Name of the schema where the stored procedures for tests are stored.
 * IN PREV_EXEC_ID
 *   Previous execution ID to run the tests in that same order. Useful when
 *   tests were executed randomly and generate an error.
 * IN TEST_NAME
 *   Procedure to execute. If null, all tests of the given schema are
 *   executed.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE RUN_SUITE (
  IN SCHEMA_NAME ANCHOR SYSCAT.SCHEMATA.SCHEMANAME DEFAULT NULL,
  IN PREV_EXEC_ID ANCHOR EXECUTIONS.EXECUTION_ID DEFAULT NULL,
  IN TEST_NAME ANCHOR SYSCAT.PROCEDURES.PROCNAME DEFAULT NULL
  )
  LANGUAGE SQL
  SPECIFIC P_RUN_SUITE
  DYNAMIC RESULT SETS 2
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_RUN_SUITE: BEGIN
  -- To keep the generated error.
  DECLARE SQLCODE INTEGER DEFAULT 0;
  DECLARE SQLSTATE CHAR(5) DEFAULT '00000';
  DECLARE MSG_TEXT ANCHOR MAX_SIGNAL.SIGNAL; -- Message from signal.

  DECLARE LOGGER_ID SMALLINT;
  DECLARE CURRENT_STATUS ANCHOR EXECUTION_REPORTS.STATUS; -- Internal status.
  DECLARE CONTINU BOOLEAN DEFAULT TRUE; -- Stops the execution.
  DECLARE SENTENCE ANCHOR MAX_VALUES.SENTENCE; -- Dynamic statement
    -- to execute.
  DECLARE TABLENAME ANCHOR SYSCAT.TABLES.TABNAME; -- Name of the table.
  DECLARE REPORT_CREATED BOOLEAN DEFAULT FALSE; -- If a report was created.
  DECLARE PREVIOUS_SCHEMA ANCHOR SYSCAT.SCHEMATA.SCHEMANAME; -- Previous schema
    -- to test itself.
  DECLARE PREVIOUS_TESTNAME ANCHOR SYSCAT.PROCEDURES.PROCNAME; -- Previous test
    -- name to test itself.
  DECLARE PREVIOUS_EXEC_ID ANCHOR EXECUTIONS.EXECUTION_ID; -- Previous
    -- exec id to test itself.
  DECLARE PREVIOUS_PROCS_NAMES PROCS_NAMES_TYPE; -- Previous list.
  DECLARE INIT_TIME TIMESTAMP;
  DECLARE PROC_NAME_FOUND ANCHOR SYSCAT.PROCEDURES.PROCNAME; -- If the given
    -- test name does not exist.
  DECLARE RET INTEGER DEFAULT 0;

  DECLARE EXISTING_LOCK CONDITION FOR SQLSTATE '23505';
  DECLARE STMT STATEMENT; -- Statement to execute.

  DECLARE GLOBAL_REPORT_CURSOR CURSOR
    WITH RETURN TO CALLER
    FOR GLOBAL_REPORT_RS;
  DECLARE REPORT_CURSOR CURSOR
    WITH RETURN TO CLIENT
    FOR REPORT_RS;
  DECLARE CONTINUE HANDLER FOR EXISTING_LOCK
    BEGIN
     INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
       VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS, 'There is another '
       || 'concurrent execution on of the same test suite.');
     INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
       VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS, 'If not, please '
       || 'execute CALL DB2UNIT.RELEASE_LOCK(''' || COALESCE(SCHEMA_NAME,
       'SUITE_NAME') || ''')');
     CALL LOGGER.WARN(LOGGER_ID, 'There is another concurrent execution of the '
       || 'same test suite');
     SET CONTINU = FALSE;
    END;
  DECLARE EXIT HANDLER FOR SQLWARNING
    BEGIN
     DECLARE COPY_SQLSTATE CHAR(5);
     DECLARE COPY_SQLCODE INTEGER;
     SET COPY_SQLSTATE = SQLSTATE, COPY_SQLCODE = SQLCODE;
     INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
       VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS, 'Warning(4): SQLCode'
       || COALESCE(COPY_SQLCODE, -1) || '-SQLState' || COALESCE(COPY_SQLSTATE,
       'EMPTY'));
     CALL LOGGER.WARN(LOGGER_ID, '< with warning(4) ' || COALESCE(COPY_SQLSTATE,
       'EMPTY'));
    END;
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
     DECLARE COPY_SQLSTATE CHAR(5);
     DECLARE COPY_SQLCODE INTEGER;
     DECLARE LOGS_CURSOR CURSOR
       WITH RETURN TO CLIENT
       FOR LOGS_RS;
     SET COPY_SQLSTATE = SQLSTATE, COPY_SQLCODE = SQLCODE;
     GET DIAGNOSTICS EXCEPTION 1 MSG_TEXT = MESSAGE_TEXT;
     INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
       VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS,
       'Exception(4): SQLCode ' || COALESCE(COPY_SQLCODE, -1) || ', SQLState '
       || COALESCE(COPY_SQLSTATE, 'EMPTY'));
     -- Probably not the last one if other concurrent app inserts in between.
     SET SENTENCE = 'SELECT MESSAGE '
       || 'FROM LOGS '
       || 'WHERE DATE_UNIQ = (SELECT MAX(DATE_UNIQ) FROM LOGS)';
     PREPARE LOGS_RS FROM SENTENCE;
     CALL LOGGER.WARN(LOGGER_ID, '< with exception(4) SQLCode'
       || COALESCE(COPY_SQLCODE, -1) || '-SQLState' || COALESCE(COPY_SQLSTATE,
       'EMPTY') || '-' || COALESCE(MSG_TEXT, 'No message'));
     OPEN LOGS_CURSOR;
    END;

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.RUN_SUITE', LOGGER_ID);
  CALL LOGGER.WARN(LOGGER_ID, '>');
  SET INIT_TIME = CURRENT TIMESTAMP;

  -- INITIALIZATION
  -- Set the initial status
  SET CURRENT_STATUS = 'Initialization';
  CALL LOGGER.INFO(LOGGER_ID, 'Execution for ' || COALESCE(SCHEMA_NAME,
    'NULL schema'));
  CALL LOGGER.INFO(LOGGER_ID, CURRENT_STATUS);

  -- Check previous values (for self testing)
  IF (CUR_SCHEMA IS NOT NULL) THEN
   SET PREVIOUS_EXEC_ID = EXEC_ID;
   SET PREVIOUS_SCHEMA = CUR_SCHEMA;
   SET CUR_SCHEMA = NULL;
   SET PREVIOUS_TESTNAME = TESTNAME;
   SET PREVIOUS_PROCS_NAMES = PROCS_NAMES;
   SET PROCS_NAMES = NULL;
   SET PREVIOUS_TEST_RESULT = TEST_RESULT;
   SET TEST_RESULT = NO_RESULT;
   CALL LOGGER.INFO(LOGGER_ID, 'Self testing values');
  END IF;

  SET EXEC_ID = GET_RANDOM_ID();
  SET EXEC_ID_COPY = EXEC_ID;
  CALL LOGGER.INFO(LOGGER_ID, 'EXEC_ID: ' || EXEC_ID);

  -- Check input values.
  IF (PREV_EXEC_ID IS NOT NULL AND TEST_NAME IS NOT NULL) THEN
   INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
     VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS, TRIM(SUBSTR('Previous '
     || 'execution ID (PREV_EXEC_ID) and a test name (TEST_NAME) were given ('
     || PREV_EXEC_ID || ', ' || TEST_NAME || ')', 1, 128)));
   CALL LOGGER.INFO(LOGGER_ID, 'Previous execution ID (PREV_EXEC_ID) and a '
     || 'test name (TEST_NAME) were given (' || PREV_EXEC_ID || ', '
     || TEST_NAME || ')');
   SET CONTINU = FALSE;
  END IF;

  IF (CONTINU = TRUE) THEN
   IF (SCHEMA_NAME IS NULL) THEN
    SET SCHEMA_NAME = CURRENT SCHEMA;
   END IF;
   SET SCHEMA_NAME = PROCESS_SCHEMA(SCHEMA_NAME);
   MERGE INTO SUITES AS IN
     USING (VALUES (SCHEMA_NAME)) AS EX (SUITE_NAME)
     ON (IN.SUITE_NAME = EX.SUITE_NAME)
     WHEN NOT MATCHED THEN
     INSERT (SUITE_NAME) VALUES (EX.SUITE_NAME)
     ELSE IGNORE;

   -- Validates the schema
   SET CUR_SCHEMA = (SELECT TRIM(SCHEMANAME)
     FROM SYSCAT.SCHEMATA
     WHERE SCHEMANAME = PROCESS_SCHEMA(SCHEMA_NAME));
   IF (CUR_SCHEMA IS NULL) THEN
    SET CUR_SCHEMA = (SELECT TRIM(SCHEMANAME)
      FROM SYSCAT.SCHEMATA
      WHERE SCHEMANAME = PROCESS_SCHEMA(UPPER(SCHEMA_NAME)));
    IF (CUR_SCHEMA IS NULL) THEN
     INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
       VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS, SUBSTR(
       'The given schema does not exists: ' || COALESCE(SCHEMA_NAME, 'NULL'), 1,
       128));
     CALL LOGGER.DEBUG(LOGGER_ID, 'The given schema does not exists');
     SET CONTINU = FALSE;
    END IF;
   ELSE
    -- Puts the lock for the current suite.
    INSERT INTO SUITE_LOCKS (NAME) VALUES (SCHEMA_NAME);
    INSERT INTO SUITES_EXECUTIONS (SUITE_NAME, EXECUTION_ID)
      VALUES (SCHEMA_NAME, EXEC_ID);

    -- If there is not another execution of the same test suite.
    IF (CONTINU = TRUE) THEN
     CALL LOGGER.INFO(LOGGER_ID, CUR_SCHEMA || ':' || EXEC_ID);
     INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
       VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS, LICENSE);
     INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
       VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS, SUBSTR('Execution '
       || 'of ' || CUR_SCHEMA || ' with ID ' || EXEC_ID, 1, 128));
    END IF;
   END IF;
  END IF;

  -- PREPARE REPORT
  -- Creates the report's table if it does not exist.
  IF (CONTINU = TRUE) THEN
   SET CURRENT_STATUS = 'Prepare Report';
   CALL LOGGER.INFO(LOGGER_ID, CURRENT_STATUS);

   SET TABLENAME = (SELECT TABNAME
     FROM SYSCAT.TABLES
     WHERE TABSCHEMA = PROCESS_SCHEMA(CUR_SCHEMA)
     AND TABNAME = REPORTS_TABLE);
   -- Create the table only if it does not exist.
   IF (TABLENAME IS NULL) THEN
    SET SENTENCE = 'CREATE TABLE ' || CUR_SCHEMA || '.' || REPORTS_TABLE
      || ' LIKE ' || UTILITY_SCHEMA || '.' || REPORTS_TABLE;
    CALL LOGGER.DEBUG(LOGGER_ID, 'Sentence: ' || SENTENCE);
    PREPARE STMT FROM SENTENCE;
    EXECUTE STMT;
    INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
      VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS, SUBSTR(
      'The reports table created: ' || CUR_SCHEMA || '.' || REPORTS_TABLE, 1,
      128));
    CALL LOGGER.INFO(LOGGER_ID, 'Table created for ' || CUR_SCHEMA);
   ELSE
    INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
      VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS, TRIM(SUBSTR(
      'The reports table already exist: ' || CUR_SCHEMA || '.'
      || REPORTS_TABLE, 1, 128)));
    CALL LOGGER.DEBUG(LOGGER_ID, 'The reports table already exist');
   END IF;
   SET SENTENCE = 'ALTER TABLE ' || CUR_SCHEMA || '.' || REPORTS_TABLE
     || ' ALTER COLUMN SUITE_NAME SET WITH DEFAULT '''
     || CUR_SCHEMA || '''';
   CALL LOGGER.DEBUG(LOGGER_ID, 'Sentence: ' || SENTENCE);
   PREPARE STMT FROM SENTENCE;
   EXECUTE STMT;
   SET REPORT_CREATED = TRUE;
  END IF;

  -- GENERATE LIST
  -- Generates the list of procedures to execute.
  IF (CONTINU = TRUE) THEN
   SET CURRENT_STATUS = 'Generate list';
   CALL LOGGER.INFO(LOGGER_ID, CURRENT_STATUS);

   IF (TEST_NAME IS NULL) THEN
    SET PROCS_NAMES = ARRAY[
      SELECT PROCNAME
      FROM SYSCAT.PROCEDURES
      WHERE PROCSCHEMA = PROCESS_SCHEMA(CUR_SCHEMA)
      AND PROCNAME LIKE 'TEST_%'
      AND LANGUAGE = 'SQL'
      AND PARM_COUNT = 0
      ORDER BY PROCNAME];
   ELSE
    SET PROC_NAME_FOUND = (SELECT PROCNAME
      FROM SYSCAT.PROCEDURES
      WHERE PROCSCHEMA = PROCESS_SCHEMA(CUR_SCHEMA)
      AND PROCNAME = TEST_NAME
      AND LANGUAGE = 'SQL'
      AND PARM_COUNT = 0);
    IF (PROC_NAME_FOUND IS NULL) THEN
     SET PROC_NAME_FOUND = (SELECT PROCNAME
       FROM SYSCAT.PROCEDURES
       WHERE PROCSCHEMA = PROCESS_SCHEMA(CUR_SCHEMA)
       AND PROCNAME = UPPER(TEST_NAME)
       AND LANGUAGE = 'SQL'
       AND PARM_COUNT = 0);
     IF (PROC_NAME_FOUND IS NOT NULL) THEN
      SET PROCS_NAMES[1] = TEST_NAME;
     ELSE
      SET CONTINU = FALSE;
      INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
        VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS, 'Test "'
        || TEST_NAME || '" does not exist in suite ' || CUR_SCHEMA);
      CALL LOGGER.ERROR(LOGGER_ID, 'Test "' || TEST_NAME
        || '" does not exist in suite ' || CUR_SCHEMA);
      CALL RELEASE_LOCK(SCHEMA_NAME);
     END IF;
    ELSE
     SET PROCS_NAMES[1] = TEST_NAME;
    END IF;
   END IF;
  END IF;

  -- SORT LIST
  -- Sort the list of procedures to execute
  IF (CONTINU = TRUE) THEN
   SET CURRENT_STATUS = 'Sort list';
   CALL LOGGER.INFO(LOGGER_ID, CURRENT_STATUS);

   CALL SORT_PROC_NAMES(PREV_EXEC_ID);
   CALL SAVE_LIST();
  END IF;

  -- EXECUTE
  -- Execute the tests.
  IF (CONTINU = TRUE) THEN
   CALL EXECUTION(CURRENT_STATUS);
   GET DIAGNOSTICS RET = DB2_RETURN_STATUS;
   SET PROCS_NAMES = NULL;
  END IF;

  IF (CONTINU = TRUE) THEN
   -- Release the lock.
   CALL RELEASE_LOCK(SCHEMA_NAME);

   -- CALCULATING TIME
   SET CURRENT_STATUS = 'Calculating time';
   CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.RUN_SUITE', LOGGER_ID);
   CALL LOGGER.INFO(LOGGER_ID, CURRENT_STATUS);

   -- Elapsed time.
   IF (PREVIOUS_SCHEMA IS NULL) THEN
    UPDATE SUITES_EXECUTIONS SET
      DURATION = TIMESTAMPDIFF(2, CURRENT TIMESTAMP - INIT_TIME)
      WHERE EXECUTION_ID = EXEC_ID
      AND SUITE_NAME = CUR_SCHEMA;
    INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
      VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS, 'Total execution time '
      || 'is: ' || TIMESTAMPDIFF(2, CURRENT TIMESTAMP - INIT_TIME)
      || ' seconds');
   END IF;
  END IF;

  -- GENERATING REPORTS
  -- Generates the reports (not for self testing)
  SET CURRENT_STATUS = 'Generating reports';
  CALL LOGGER.INFO(LOGGER_ID, CURRENT_STATUS);

  -- Only create reports when no-self-testing.
  IF (PREVIOUS_SCHEMA IS NULL) THEN
   IF (REPORT_CREATED = TRUE) THEN
    SET SENTENCE = 'SELECT VARCHAR(SUBSTR(TEST_NAME, 1 , 16), 16) AS TEST, '
      || 'FINAL_STATE, TIME AS MICROSECONDS, '
      || 'VARCHAR(SUBSTR(MESSAGE, 1, 64), 64) AS MESSAGE '
      || 'FROM ' || CUR_SCHEMA || '.' || REPORTS_TABLE || ' '
      || 'WHERE EXECUTION_ID = ' || EXEC_ID || ' '
      || 'ORDER BY DATE';
    CALL LOGGER.DEBUG(LOGGER_ID, 'Sentence: ' || SENTENCE);
    PREPARE REPORT_RS FROM SENTENCE;
    OPEN REPORT_CURSOR;
   END IF;
   SET SENTENCE = 'SELECT TIME(DATE) AS TIME, EXECUTION_ID,'
     || 'VARCHAR(SUBSTR(STATUS, 1, 21), 21) AS STATUS, '
     || 'VARCHAR(SUBSTR(MESSAGE_REPORT, 1, 62), 62) AS MESSAGE '
     || 'FROM ' || UTILITY_SCHEMA || '.EXECUTION_REPORTS '
     || 'WHERE EXECUTION_ID = ' || EXEC_ID || ' '
     || 'ORDER BY DATE';
   CALL LOGGER.DEBUG(LOGGER_ID, 'Sentence: ' || SENTENCE);
   PREPARE GLOBAL_REPORT_RS FROM SENTENCE;
   OPEN GLOBAL_REPORT_CURSOR;
  END IF;

  -- CLEAN ENVIRONMENT
  -- Cleans environment.
  SET CURRENT_STATUS = 'Clean environment';
  CALL LOGGER.INFO(LOGGER_ID, CURRENT_STATUS);

  SET LAST_EXEC_ID = EXEC_ID;
  SET LAST_SCHEMA = CUR_SCHEMA;
  SET CUR_SCHEMA = NULL;
  SET EXEC_ID = NULL;

  -- Restore previous environment (For self testing.)
  IF (PREVIOUS_SCHEMA IS NOT NULL) THEN
   CALL LOGGER.DEBUG(LOGGER_ID, 'Reestablish previous environment');
   SET EXEC_ID = PREVIOUS_EXEC_ID;
   SET EXEC_ID_COPY = PREVIOUS_EXEC_ID;
   SET CUR_SCHEMA = PREVIOUS_SCHEMA;
   SET TESTNAME = PREVIOUS_TESTNAME;
   SET PROCS_NAMES = PREVIOUS_PROCS_NAMES;
   SET TEST_RESULT = PREVIOUS_TEST_RESULT;
   SET PREVIOUS_EXEC_ID = NULL;
   SET PREVIOUS_SCHEMA = NULL;
   SET PREVIOUS_TESTNAME = NULL;
   SET PREVIOUS_PROCS_NAMES = NULL;
   SET PREVIOUS_TEST_RESULT = NO_RESULT;
  END IF;

  IF (CONTINU = FALSE) THEN
   SET RET = 2;
  END IF;

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.RUN_SUITE', LOGGER_ID);
  CALL LOGGER.WARN(LOGGER_ID, '<');
  RETURN RET;
 END P_RUN_SUITE @

/**
 * Execute the tests defined in a set of stored procedure in the given schema.
 *
 * IN SCHEMA_NAME
 *   Name of the schema where the stored procedures for tests are stored.
 * IN PREV_EXEC_ID
 *   Previous execution ID to run the tests in that same order. Useful when
 *   tests were executed randomly and generate an error.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE RUN_SUITE (
  IN SCHEMA_NAME ANCHOR SYSCAT.SCHEMATA.SCHEMANAME,
  IN PREV_EXEC_ID ANCHOR EXECUTIONS.EXECUTION_ID DEFAULT NULL
  )
  LANGUAGE SQL
  SPECIFIC P_RUN_SUITE_ALL
  DYNAMIC RESULT SETS 2
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_RUN_SUITE_ALL: BEGIN
  DECLARE SENTENCE ANCHOR MAX_VALUES.SENTENCE; -- Dynamic statement
    -- to execute.
  DECLARE RET INTEGER DEFAULT 0;
  DECLARE STMT STATEMENT; -- Statement to execute.
  DECLARE GLOBAL_REPORT_CURSOR CURSOR
    WITH RETURN TO CALLER
    FOR GLOBAL_REPORT_RS;

  CALL RUN_SUITE(SCHEMA_NAME, PREV_EXEC_ID, NULL);
  GET DIAGNOSTICS RET = DB2_RETURN_STATUS;

  SET SENTENCE = 'SELECT TIME(DATE) AS TIME, EXECUTION_ID,'
    || 'VARCHAR(SUBSTR(STATUS, 1, 21), 21) AS STATUS, '
    || 'VARCHAR(SUBSTR(MESSAGE_REPORT, 1, 62), 62) AS MESSAGE '
    || 'FROM ' || UTILITY_SCHEMA || '.EXECUTION_REPORTS '
    || 'WHERE EXECUTION_ID = ' || EXEC_ID_COPY || ' '
    || 'ORDER BY DATE';
  PREPARE GLOBAL_REPORT_RS FROM SENTENCE;
  OPEN GLOBAL_REPORT_CURSOR;
  RETURN RET;
 END P_RUN_SUITE_ALL @

/**
 * Register a given suite in the framework. This helps to produce an output
 * of all registered suites to execute all of them.
 *
 * IN SCHEMA_NAME
 *   Name of the suite to register.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE REGISTER_SUITE (
  IN SCHEMA_NAME ANCHOR SYSCAT.SCHEMATA.SCHEMANAME
  )
  LANGUAGE SQL
  SPECIFIC P_REGISTER_SUITE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_REGISTER_SUITE: BEGIN
  DECLARE ALREADY_EXIST CONDITION FOR SQLSTATE '23505';
  DECLARE CONTINUE HANDLER FOR ALREADY_EXIST BEGIN END;
  INSERT INTO SUITES (SUITE_NAME) VALUES (SCHEMA_NAME);
 END P_REGISTER_SUITE @

/**
 * Returns the Execution Id of the most recent execution.
 *
 * RETURNS ExecID of the most recent execution.
 */
ALTER MODULE DB2UNIT ADD
  FUNCTION GET_LAST_EXEC_ID (
  ) RETURNS ANCHOR EXECUTIONS.EXECUTION_ID
  LANGUAGE SQL
  READS SQL DATA
  NOT DETERMINISTIC
  SPECIFIC F_GET_LAST_EXEC_ID
  NO EXTERNAL ACTION
 F_GET_LAST_EXEC_ID: BEGIN
  RETURN LAST_EXEC_ID;
 END F_GET_LAST_EXEC_ID @

/*
 * Returns the Execution Id of the current execution.
 *
 * RETURNS ExecID of the current execution.
 */
ALTER MODULE DB2UNIT ADD
  FUNCTION GET_CURRENT_EXEC_ID (
  ) RETURNS ANCHOR EXECUTIONS.EXECUTION_ID
  LANGUAGE SQL
  READS SQL DATA
  NOT DETERMINISTIC
  SPECIFIC F_GET_CURRENT_EXEC_ID
  NO EXTERNAL ACTION
 F_GET_CURRENT_EXEC_ID: BEGIN
  RETURN EXEC_ID;
 END F_GET_CURRENT_EXEC_ID @

/**
 * Returns the schema of the most recent execution.
 *
 * RETURNS Test suite name the most recent execution.
 */
ALTER MODULE DB2UNIT ADD
  FUNCTION GET_LAST_TEST_SUITE_NAME (
  ) RETURNS ANCHOR SYSCAT.SCHEMATA.SCHEMANAME
  LANGUAGE SQL
  READS SQL DATA
  NOT DETERMINISTIC
  SPECIFIC F_GET_LAST_TEST_SUITE_NAME
  NO EXTERNAL ACTION
 F_GET_LAST_TEST_SUITE_NAME: BEGIN
  RETURN LAST_SCHEMA;
 END F_GET_LAST_TEST_SUITE_NAME @

/*
 * Returns the schema of the current execution.
 *
 * RETURNS Test suite name of the current execution.
 */
ALTER MODULE DB2UNIT ADD
  FUNCTION GET_CURRENT_TEST_SUITE_NAME (
  ) RETURNS ANCHOR SYSCAT.SCHEMATA.SCHEMANAME
  LANGUAGE SQL
  READS SQL DATA
  NOT DETERMINISTIC
  SPECIFIC F_GET_CURRENT_TEST_SUITE_NAME
  NO EXTERNAL ACTION
 F_GET_CURRENT_TEST_SUITE_NAME: BEGIN
  RETURN CUR_SCHEMA;
 END F_GET_CURRENT_TEST_SUITE_NAME @

/**
 * Retrieves the order of the test of the most recent execution.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE GET_LAST_EXECUTION_ORDER(
  )
  LANGUAGE SQL
  SPECIFIC P_GET_LAST_EXECUTION_ORDER
  DYNAMIC RESULT SETS 1
  READS SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_GET_LAST_EXECUTION_ORDER: BEGIN
  DECLARE SENTENCE VARCHAR(256);
  DECLARE STMT STATEMENT;
  DECLARE ORDER_CURSOR CURSOR
    WITH RETURN TO CLIENT
    FOR ORDER_RS;

  IF (LAST_EXEC_ID IS NULL OR LAST_SCHEMA IS NULL OR LAST_SCHEMA = '') THEN
   SIGNAL SQLSTATE VALUE 'DBUN1'
     SET MESSAGE_TEXT = 'Impossible to retrieve the last execution.';
  END IF;
  SET SENTENCE = 'SET CURRENT SCHEMA ' || UTILITY_SCHEMA;
  PREPARE STMT FROM SENTENCE;
  EXECUTE STMT;
  SET SENTENCE = 'SELECT SUITE_NAME, EXECUTION_ID, POSITION, TEST_NAME '
    || 'FROM ' || UTILITY_SCHEMA || '.SORTS '
    || 'WHERE SUITE_NAME = ''' || LAST_SCHEMA || ''' '
    || 'AND EXECUTION_ID = ' || LAST_EXEC_ID;
  PREPARE ORDER_RS FROM SENTENCE;
  OPEN ORDER_CURSOR;
 END P_GET_LAST_EXECUTION_ORDER @

/**
 * Returns a cursor with the results of the most recent executions of each
 * test suite in the database.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE REPORT_RECENT_EXECUTIONS(
  )
  LANGUAGE SQL
  SPECIFIC P_REPORT_RECENT_EXECUTIONS
  DYNAMIC RESULT SETS 1
  READS SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_REPORT_RECENT_EXECUTIONS: BEGIN
  DECLARE EXEC_CURSOR CURSOR
    WITH RETURN TO CALLER FOR
    WITH T AS (
     SELECT A.SUITE_NAME SUITE_NAME,
      B.DATE DATE, A.TOTAL_TESTS TOTAL_TESTS, A.PASSED_TESTS PASSED_TESTS,
      A.FAILED_TESTS FAILED_TESTS, A.ERROR_TESTS ERROR_TESTS,
      A.UNEXEC_TESTS UNEXEC_TESTS
     FROM SUITES_EXECUTIONS A JOIN EXECUTIONS B
     ON A.EXECUTION_ID = B.EXECUTION_ID)
    SELECT T1.SUITE_NAME, T1.TOTAL_TESTS, T1.PASSED_TESTS, T1.FAILED_TESTS,
     T1.ERROR_TESTS, T1.UNEXEC_TESTS
    FROM T T1 LEFT OUTER JOIN T T2
    ON (T1.SUITE_NAME = T2.SUITE_NAME
    AND T1.DATE < T2.DATE)
    WHERE T2.SUITE_NAME IS NULL
    ORDER BY T1.SUITE_NAME;
  OPEN EXEC_CURSOR;
 END P_REPORT_RECENT_EXECUTIONS @

-- Writes in the TAP report
ALTER MODULE DB2UNIT ADD
  PROCEDURE WRITE_IN_TAP_REPORT(
  IN MESSAGE VARCHAR(256),
  INOUT INDEX SMALLINT
  )
  LANGUAGE SQL
  SPECIFIC P_WRITE_IN_TAP_REPORT
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_WRITE_IN_TAP_REPORT: BEGIN
  INSERT INTO TAP_REPORT (NUMBER, MESSAGE)
    VALUES (INDEX, MESSAGE);
  SET INDEX = INDEX + 1;
 END P_WRITE_IN_TAP_REPORT @

-- Creates a TAP (Test Anything Protocol) report.
ALTER MODULE DB2UNIT ADD
  PROCEDURE CREATE_TAP_REPORT(
  )
  LANGUAGE SQL
  SPECIFIC P_CREATE_TAP_REPORT
  DYNAMIC RESULT SETS 1
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_CREATE_TAP_REPORT: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE TOTAL ANCHOR SUITES_EXECUTIONS.TOTAL_TESTS;
  DECLARE MESSAGE VARCHAR(256);
  DECLARE SENTENCE VARCHAR(1024);
  DECLARE INDEX SMALLINT;
  DECLARE AT_END BOOLEAN; -- End of the cursor.
  DECLARE STATUS ANCHOR REPORT_TESTS.FINAL_STATE;
  DECLARE COMMENT VARCHAR(128);
  DECLARE POSITION SMALLINT;
  DECLARE TESTS_CURSOR CURSOR
    FOR TESTS_RS;
  DECLARE TAP_CURSOR CURSOR
    WITH RETURN TO CALLER FOR
    SELECT MESSAGE FROM TAP_REPORT;
  DECLARE CONTINUE HANDLER FOR NOT FOUND
    SET AT_END = TRUE;

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.CREATE_TAP_REPORT',
    LOGGER_ID);

  DELETE FROM TAP_REPORT;

  IF (LAST_EXEC_ID IS NULL OR LAST_SCHEMA IS NULL OR LAST_SCHEMA = ' ') THEN
   SIGNAL SQLSTATE VALUE 'DBUN1'
     SET MESSAGE_TEXT = 'Impossible to retrieve the last execution.';
  END IF;
  SET TOTAL = (SELECT TOTAL_TESTS FROM SUITES_EXECUTIONS
    WHERE SUITE_NAME = LAST_SCHEMA
    AND EXECUTION_ID = LAST_EXEC_ID);

  SET INDEX = 1;
  CALL WRITE_IN_TAP_REPORT('TAP version 13', INDEX);
  IF (TOTAL = 0) THEN
   CALL WRITE_IN_TAP_REPORT('1..0 # skip', INDEX);
  ELSE
   CALL WRITE_IN_TAP_REPORT('1..' || TOTAL, INDEX);
  END IF;

  SET SENTENCE = 'SELECT '
    || 'R.FINAL_STATE STATE, SO.POSITION POSITION, R.TEST_NAME TEST_NAME '
    || 'FROM ' || UTILITY_SCHEMA || '.SUITES_EXECUTIONS SE JOIN '
    || UTILITY_SCHEMA || '.SORTS SO '
    || 'ON (SE.SUITE_NAME = SO.SUITE_NAME '
    || ' AND SE.EXECUTION_ID = SO.EXECUTION_ID) '
    || 'JOIN ' || UTILITY_SCHEMA || '.RESULT_TESTS R '
    || 'ON (SE.SUITE_NAME = R.SUITE_NAME AND SE.EXECUTION_ID = R.EXECUTION_ID) '
    || 'AND SO.TEST_NAME = R.TEST_NAME '
    || 'AND R.EXECUTION_ID = ' || LAST_EXEC_ID || ' '
    || 'AND R.SUITE_NAME = ''' || LAST_SCHEMA || ''' '
    || 'ORDER BY DATE';
  CALL LOGGER.INFO(LOGGER_ID, 'Sentence ' || SENTENCE);
  PREPARE TESTS_RS FROM SENTENCE;
  OPEN TESTS_CURSOR;
  SET AT_END = FALSE;
  FETCH TESTS_CURSOR INTO STATUS, POSITION, MESSAGE;
  WHILE (AT_END = FALSE) DO
   IF (STATUS = RESULT_PASSED) THEN
    CALL WRITE_IN_TAP_REPORT('ok ' || POSITION || ' ' || COALESCE(MESSAGE, ''),
      INDEX);
   ELSE
    IF (STATUS = RESULT_UNSTARTED) THEN
     CALL WRITE_IN_TAP_REPORT('not ok ' || POSITION || ' '
       || COALESCE(MESSAGE, '') || ' # skip', INDEX);
     CALL WRITE_IN_TAP_REPORT(' ---', INDEX);
     CALL WRITE_IN_TAP_REPORT('  final_state: ''' || TRIM(STATUS)
       || '''', INDEX);
     CALL WRITE_IN_TAP_REPORT(' ...', INDEX);
    ELSE
     CALL WRITE_IN_TAP_REPORT('not ok ' || POSITION || ' '
       || COALESCE(MESSAGE, ''), INDEX);
     CALL WRITE_IN_TAP_REPORT(' ---', INDEX);
     CALL WRITE_IN_TAP_REPORT('  final_state: ''' || TRIM(STATUS)
       || '''', INDEX);
     BEGIN
      DECLARE AT_END2 BOOLEAN; -- End of the cursor.
      DECLARE OUTPUT_CURSOR CURSOR
        FOR OUTPUT_TS;
      DECLARE CONTINUE HANDLER FOR NOT FOUND
       SET AT_END2 = TRUE;
      -- Messages.
      SET SENTENCE = 'SELECT MESSAGE '
        || 'FROM ' || LAST_SCHEMA || '.REPORT_TESTS '
        || 'WHERE TEST_NAME = ''' || MESSAGE || ''' '
        || 'AND FINAL_STATE IS NULL '
        || 'AND EXECUTION_ID = ' || LAST_EXEC_ID;
      CALL LOGGER.INFO(LOGGER_ID, 'Sentence ' || SENTENCE);
      PREPARE OUTPUT_TS FROM SENTENCE;
      OPEN OUTPUT_CURSOR;
      FETCH OUTPUT_CURSOR INTO MESSAGE;
      SET AT_END2 = FALSE;
      WHILE (AT_END2 = FALSE) DO
       IF (MESSAGE IS NOT NULL AND MESSAGE <> '') THEN
        CALL WRITE_IN_TAP_REPORT('  Message: ''' || COALESCE(MESSAGE, '')
          || '''', INDEX);
       END IF;
       FETCH OUTPUT_CURSOR INTO MESSAGE;
      END WHILE;
     END ;
     CALL WRITE_IN_TAP_REPORT(' ...', INDEX);
    END IF;
   END IF;
   FETCH TESTS_CURSOR INTO STATUS, POSITION, MESSAGE;
  END WHILE;

  OPEN TAP_CURSOR;

 END P_CREATE_TAP_REPORT @

/**
 * Returns the name of the test currently being executed.
 *
 * RETURNS The name of the current stored procedure.
 */
ALTER MODULE DB2UNIT ADD
  FUNCTION GET_CURRENT_TESTNAME (
  ) RETURNS ANCHOR SYSCAT.PROCEDURES.PROCNAME
  LANGUAGE SQL
  READS SQL DATA
  NOT DETERMINISTIC
  SPECIFIC F_GET_CURRENT_TESTNAME
  NO EXTERNAL ACTION
 F_GET_CURRENT_TESTNAME: BEGIN
  RETURN TESTNAME;
 END F_GET_CURRENT_TESTNAME @

/**
 * Changes last message to executing. It should be used only for self-testing.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE BACK_TO_EXECUTING (
  )
  LANGUAGE SQL
  SPECIFIC P_BACK_TO_EXECUTING
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_BACK_TO_EXECUTING: BEGIN
  SET TEST_RESULT = EXECUTING;
 END P_BACK_TO_EXECUTING @

/**
 * Cleans the environment, if a previous execution did not finished correctly.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE CLEAN (
  )
  LANGUAGE SQL
  SPECIFIC P_CLEAN
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_CLEAN: BEGIN
  SET CUR_SCHEMA = NULL;
  SET LAST_SCHEMA = NULL;
  SET EXEC_ID = NULL;
  SET LAST_EXEC_ID = NULL;
  SET TESTNAME = NULL;
 END P_CLEAN @

/**
 * Clean values from last execution..
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE CLEAN_LAST_EXEC (
  )
  LANGUAGE SQL
  SPECIFIC P_CLEAN_LAST_EXEC
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_CLEAN_LAST_EXEC: BEGIN
  SET LAST_SCHEMA = NULL;
  SET LAST_EXEC_ID = NULL;
 END P_CLEAN_LAST_EXEC @

/**
 * Cleans the last test execution. This is useful for self-testing.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE CLEAN_TEST_RESULT (
  )
  LANGUAGE SQL
  SPECIFIC P_CLEAN_TEST_RESULT
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_CLEAN_TEST_RESULT: BEGIN
  SET TEST_RESULT = NO_RESULT;
  SET TEST_MESSAGE = NULL;
 END P_CLEAN_TEST_RESULT @

/**
 * Deletes the content of all tables in this framework.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE RESET_TABLES (
  )
  LANGUAGE SQL
  SPECIFIC P_RESET_TABLES
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_RESET_TABLES: BEGIN
  DECLARE AT_END BOOLEAN; -- End of the cursor.
  DECLARE SCHEMA ANCHOR SYSCAT.SCHEMATA.SCHEMANAME;
  DECLARE STATEMENT VARCHAR(256);
  DECLARE INEXISTANT_TABLE CONDITION FOR SQLSTATE '42704';
  DECLARE STMT STATEMENT;
  DECLARE SCHEMATA CURSOR WITH HOLD FOR
    SELECT SUITE_NAME
    FROM SUITES S;
  DECLARE CONTINUE HANDLER FOR NOT FOUND
    SET AT_END = TRUE;
  DECLARE CONTINUE HANDLER FOR INEXISTANT_TABLE BEGIN END;

  OPEN SCHEMATA;
  SET AT_END = FALSE;
  FETCH SCHEMATA INTO SCHEMA;
  WHILE (AT_END = FALSE) DO
   SET STATEMENT = 'DROP TABLE ' || TRIM(SCHEMA) || '.' || REPORTS_TABLE;
   PREPARE STMT FROM STATEMENT;
   EXECUTE STMT;
   FETCH SCHEMATA INTO SCHEMA;
  END WHILE;

  DELETE FROM SORTS;
  DELETE FROM SUITES_EXECUTIONS;
  DELETE FROM SUITE_LOCKS;
  DELETE FROM EXECUTION_REPORTS;
  DELETE FROM SUITES;
  DELETE FROM EXECUTIONS;
  DELETE FROM RESULT_TESTS;
 END P_RESET_TABLES @

/**
 * Release the lock for a given suite. It should be used when a test suite
 * execution is cancelled and it does not finish correctly.
 *
 * IN NAME
 *   Name of the test suite for remove its lock.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE RELEASE_LOCK (
  NAME ANCHOR SYSCAT.SCHEMATA.SCHEMANAME
  )
  LANGUAGE SQL
  SPECIFIC P_RELEASE_LOCK
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_RELEASE_LOCK: BEGIN
  DECLARE STATEMENT VARCHAR(256);
  DECLARE CUR_SCHEMA ANCHOR SYSCAT.SCHEMATA.SCHEMANAME;
  DECLARE LOGGER_ID SMALLINT;
  DECLARE STMT STATEMENT;
  DECLARE EXIT HANDLER FOR NOT FOUND SET STATEMENT = '';

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.RELEASE_LOCK',
    LOGGER_ID);

  CALL LOGGER.INFO(LOGGER_ID, 'Releasing lock for schema '
    || COALESCE(NAME, 'NULL'));

  SET NAME = PROCESS_SCHEMA(NAME);
  SET CUR_SCHEMA = (SELECT SCHEMANAME
    FROM SYSCAT.SCHEMATA
    WHERE SCHEMANAME = NAME);
  IF (CUR_SCHEMA IS NULL) THEN
   SET CUR_SCHEMA = (SELECT SCHEMANAME
     FROM SYSCAT.SCHEMATA
     WHERE SCHEMANAME = UPPER(NAME));
   IF (CUR_SCHEMA IS NOT NULL) THEN
    CALL LOGGER.INFO(LOGGER_ID, 'Lock released for schema '
      || COALESCE(CUR_SCHEMA, 'NULL') || ' if existed');
    SET STATEMENT = 'DELETE FROM ' || UTILITY_SCHEMA || '.SUITE_LOCKS '
      || 'WHERE NAME = ''' || CUR_SCHEMA || '''';
    PREPARE STMT FROM STATEMENT;
    EXECUTE STMT;
   ELSE
    CALL LOGGER.WARN(LOGGER_ID, 'Schema does not exist '
      || COALESCE(NAME, 'NULL'));
   END IF;
  ELSE
   CALL LOGGER.INFO(LOGGER_ID, 'Lock released for schema '
     || COALESCE(CUR_SCHEMA, 'NULL') || ' if existed');
   SET STATEMENT = 'DELETE FROM ' || UTILITY_SCHEMA || '.SUITE_LOCKS '
     || 'WHERE NAME = ''' || CUR_SCHEMA || '''';
   PREPARE STMT FROM STATEMENT;
   EXECUTE STMT;
  END IF;
 END P_RELEASE_LOCK @

/**
 * Release all locks associated to any tests suite.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE RELEASE_LOCKS (
  )
  LANGUAGE SQL
  SPECIFIC P_RELEASE_LOCKS
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_RELEASE_LOCKS: BEGIN
  DECLARE STATEMENT VARCHAR(256);
  DECLARE STMT STATEMENT;
  SET STATEMENT = 'DELETE FROM ' || UTILITY_SCHEMA || '.SUITE_LOCKS';
  PREPARE STMT FROM STATEMENT;
  EXECUTE STMT;
 END P_RELEASE_LOCKS @

/**
 * Changes the transaction autonomous mode.
 *
 * IN AUTONOMOUS
 *   True if the procedure should be executed autonomously. False otherwise.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE SET_AUTONOMOUS (
  IN AUTONOMOUS BOOLEAN
  )
  LANGUAGE SQL
  SPECIFIC P_SET_AUTONOMOUS
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_SET_AUTONOMOUS: BEGIN
  SET AUTONOMOUS_EXEC = AUTONOMOUS;
 END P_SET_AUTONOMOUS @

/**
 * Returns the value of the current autonomous execution state.
 */
ALTER MODULE DB2UNIT ADD
  FUNCTION GET_AUTONOMOUS (
  ) RETURNS BOOLEAN
  LANGUAGE SQL
  READS SQL DATA
  NOT DETERMINISTIC
  SPECIFIC P_GET_AUTONOMOUS
  NO EXTERNAL ACTION
 P_GET_AUTONOMOUS: BEGIN
  RETURN AUTONOMOUS_EXEC;
 END P_GET_AUTONOMOUS@

/**
 * Changes the sort type for the procedures.
 *
 * IN RANDOM
 *   True if the sort should be random, false if the sort is alphabetical.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE RANDOM_SORT (
  IN RANDOM BOOLEAN
  )
  LANGUAGE SQL
  SPECIFIC P_RANDOM_SORT
  DYNAMIC RESULT SETS 0
  READS SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_RANDOM_SORT: BEGIN
  SET RANDOM_SORT = RANDOM;
 END P_RANDOM_SORT @

/**
 * Returns the current value for random sort.
 */
ALTER MODULE DB2UNIT ADD
  FUNCTION GET_RANDOM_SORT (
  ) RETURNS BOOLEAN
  LANGUAGE SQL
  READS SQL DATA
  NOT DETERMINISTIC
  SPECIFIC P_GET_RANDOM_SORT
  NO EXTERNAL ACTION
 P_GET_RANDOM_SORT: BEGIN
  RETURN RANDOM_SORT;
 END P_GET_RANDOM_SORT@

/**
 * Exports the list of registered tests into a file that can be executed
 * directly from Linux.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE EXPORT_TESTS_LIST (
  )
  LANGUAGE SQL
  SPECIFIC P_EXPORT_TESTS_LIST
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_EXPORT_TESTS_LIST: BEGIN
  DECLARE VERSION VARCHAR(256);

  SET VERSION = (SELECT OS_NAME from SYSIBMADM.ENV_SYS_INFO);
  IF (SUBSTR(VERSION, 1, 3) = 'WIN') THEN
   CALL SYSPROC.ADMIN_CMD('EXPORT TO %TMP%\listOfTestSuites OF DEL MODIFIED BY NOCHARDEL '
     || 'SELECT * FROM (SELECT ''db2 -r %TMP%\db2unit.output -v '
     || 'CALL DB2UNIT.RUN_SUITE('''''' || SUITE_NAME || '''''')'' '
     || 'FROM ' || UTILITY_SCHEMA || '.SUITES) ORDER BY RAND()');
  ELSE
   CALL SYSPROC.ADMIN_CMD('EXPORT TO /tmp/listOfTestSuites OF DEL MODIFIED BY NOCHARDEL '
     || 'SELECT * FROM (SELECT ''db2 -r /tmp/db2unit.output -v '
     || '"CALL DB2UNIT.RUN_SUITE('''''' || SUITE_NAME || '''''')" ; '
     || 'touch /tmp/sum ; '
     || 'db2 "call db2unit.get_last_execution_order()" ; '
     || 'SUM=$(cat /tmp/sum) ; '
     || 'tail -1 /tmp/db2unit.output | awk ''''/Return Status/ {print "echo $(($SUM+"$4")) > /tmp/sum"}'''' | source /dev/stdin ; '
     || 'cat /tmp/sum '' '
     || 'FROM ' || UTILITY_SCHEMA || '.SUITES) ORDER BY RAND()');
   CALL SYSPROC.ADMIN_CMD('EXPORT TO /tmp/returnCode OF DEL MODIFIED BY NOCHARDEL '
     || 'SELECT ''exit $(cat /tmp/sum)'' FROM SYSIBM.SYSDUMMY1');
  END IF;
 END P_EXPORT_TESTS_LIST@

/**
 * Shows the license of this framework.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE LICENSE (
  )
  LANGUAGE SQL
  SPECIFIC P_LICENSE
  DYNAMIC RESULT SETS 1
  READS SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_LICENSE: BEGIN
  DECLARE LICENSE_CURSOR CURSOR
    WITH RETURN FOR
    SELECT LINE
    FROM LICENSE
    ORDER BY NUMBER;
  OPEN LICENSE_CURSOR;
 END P_LICENSE @

