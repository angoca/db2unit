--#SET TERMINATOR @

/*
 This file is part of db2unit: A unit testing framework for DB2 LUW.
 Copyright (C)  2014  Andres Gomez Casanova (@AngocA)

 db2unit is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 db2unit is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

 Andres Gomez Casanova <angocaATyahooDOTcom>
*/

SET CURRENT SCHEMA DB2UNIT_1 @

/**
 * Core implementation.
 *
 * Version: 2014-04-30 1-Beta
 * Author: Andres Gomez Casanova (AngocA)
 * Made in COLOMBIA.
 */

/**
 * Constant for a passed test.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE RESULT_PASSED ANCHOR REPORT_TESTS.FINAL_STATE CONSTANT 'Passed' @

/**
 * Constant for a passed test.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE RESULT_FAILED ANCHOR REPORT_TESTS.FINAL_STATE CONSTANT 'Failed' @

/**
 * Constant for a passed test.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE RESULT_ERROR ANCHOR REPORT_TESTS.FINAL_STATE CONSTANT 'Error' @

/**
 * Constant for OneTimeSetup.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE ONE_TIME_SETUP VARCHAR(20) CONSTANT 'ONE_TIME_SETUP' @

/**
 * Constant for OneTimeSetup.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE SETUP VARCHAR(20) CONSTANT 'SETUP' @

/**
 * Constant for OneTimeSetup.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE TEAR_DOWN VARCHAR(20) CONSTANT 'TEAR_DOWN' @

/**
 * Constant for OneTimeSetup.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE ONE_TIME_TEAR_DOWN VARCHAR(20) CONSTANT 'ONE_TIME_TEAR_DOWN' @

/**
 * Max size for assertion messages.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE MAX_MESSAGE SMALLINT CONSTANT 400 @

/**
 * Unique seed for all executions to generate unique values.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE SEED BIGINT DEFAULT NULL @

/**
 * ID of the current execution.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE EXEC_ID ANCHOR EXECUTION_REPORTS.EXECUTION_ID @

/**
 * ID of the current execution. Copy for other SP.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE EXEC_ID_COPY ANCHOR EXECUTION_REPORTS.EXECUTION_ID @

/**
 * ID of the most recent execution in the current session.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE LAST_EXEC_ID ANCHOR EXECUTION_REPORTS.EXECUTION_ID @

/**
 * Current schema being tested.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE CUR_SCHEMA ANCHOR SYSCAT.SCHEMATA.SCHEMANAME @

/**
 * Current test being executed.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE TESTNAME ANCHOR SYSCAT.PROCEDURES.PROCNAME @

/**
 * Returned status after the execution.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE TEST_RESULT ANCHOR REPORT_TESTS.FINAL_STATE DEFAULT NULL @

/**
 * Description of current test. This variable is useful when no assertions are
 * called, but the test fails. It is only used when an exception is caught.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE TEST_MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT DEFAULT NULL @

/**
 * Order type to sort the proc names. False ordered by name; true random.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE RANDOM_SORT BOOLEAN DEFAULT TRUE @

/**
 * Array of procedure's names.
 */
ALTER MODULE DB2UNIT ADD
  TYPE PROCS_NAMES_TYPE AS ANCHOR SYSCAT.PROCEDURES.PROCNAME ARRAY [] @

/**
 * List of procedure.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE PROCS_NAMES PROCS_NAMES_TYPE @

/**
 * Function that escape the single quotes by replacing them with two single
 * quotes.
 *
 * IN MSG
 *   Message to analyse.
 * RETURNS Same message with single quotes escaped.
 */
ALTER MODULE DB2UNIT ADD
  FUNCTION ESCAPE_QUOTES (
  IN MSG ANCHOR REPORT_TESTS.MESSAGE
  ) RETURNS ANCHOR REPORT_TESTS.MESSAGE
  LANGUAGE SQL
  SPECIFIC F_ESCAPE_QUOTES
  DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 F_ESCAPE_QUOTES : BEGIN
  DECLARE LENGTH SMALLINT;
  DECLARE INDEX SMALLINT;
  DECLARE PRE ANCHOR REPORT_TESTS.MESSAGE;
  DECLARE RET ANCHOR REPORT_TESTS.MESSAGE;

  SET LENGTH = LENGTH(MSG);
  SET INDEX = 0;
  SET RET = '';
  WHILE (INDEX < LENGTH) DO
   SET INDEX = POSSTR(MSG, '''');
   IF (INDEX <> 0) THEN
    SET PRE = SUBSTR(MSG, 1, INDEX - 1);
    SET RET = RET || PRE || '''''';
    SET MSG = SUBSTR(MSG, INDEX + 1);
    SET INDEX = 0;
    SET LENGTH = LENGTH(MSG);
   ELSE
    SET INDEX = LENGTH;
    SET RET = RET || MSG;
   END IF;
  END WHILE;
  RETURN RET;
 END F_ESCAPE_QUOTES @

/**
 * Write a message in the tests' report. Implementation.
 *
 * IN MSG
 *   Message to insert in the report.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE WRITE_IN_REPORT_BODY (
  IN MSG ANCHOR REPORT_TESTS.MESSAGE
  )
  LANGUAGE SQL
  SPECIFIC P_WRITE_IN_REPORT_BODY
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_WRITE_IN_REPORT_BODY: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  -- To keep the generated error.
  DECLARE SQLCODE INTEGER DEFAULT 0;
  DECLARE SQLSTATE CHAR(5) DEFAULT '00000';

  DECLARE MSG_TEXT ANCHOR MAX_SIGNAL.SIGNAL; -- Message from signal.
  DECLARE SENTENCE ANCHOR MAX_VALUES.SENTENCE; -- Dynamic statement
    -- to execute.
  DECLARE STMT STATEMENT; -- Statement to execute.

  DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
     DECLARE COPY_SQLSTATE CHAR(5);
     DECLARE COPY_SQLCODE INTEGER;
     GET DIAGNOSTICS EXCEPTION 1 MSG_TEXT = MESSAGE_TEXT;
     SET COPY_SQLSTATE = SQLSTATE, COPY_SQLCODE = SQLCODE;
     INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
       VALUES (CURRENT TIMESTAMP, EXEC_ID, '', SUBSTR('Exception(1): SQLCode'
       || COALESCE(COPY_SQLCODE, -1) || '-SQLState' || COALESCE(COPY_SQLSTATE,
       'EMPTY') || 'Message:' || MSG_TEXT, 1, 256));
     CALL LOGGER.INFO(LOGGER_ID, '< With warning ' || COALESCE(COPY_SQLSTATE,
       'EMPTY') || '-' || COALESCE(COPY_SQLCODE, -1));
     COMMIT;
    END;

  CALL LOGGER.GET_LOGGER('DB2UNIT_1.DB2UNIT.WRITE_IN_REPORT_BODY', LOGGER_ID);

  SET MSG = TRIM(MSG);
  CALL LOGGER.INFO(LOGGER_ID, '>' || COALESCE(MSG, ''));
  CALL LOGGER.DEBUG(LOGGER_ID, 'Schema ' || CUR_SCHEMA);
  CALL LOGGER.DEBUG(LOGGER_ID, 'Report ' || REPORTS_TABLE);
  CALL LOGGER.DEBUG(LOGGER_ID, 'ExecId ' || EXEC_ID);
  CALL LOGGER.DEBUG(LOGGER_ID, 'TestName ' || COALESCE(TESTNAME, 'NoTestName'));
  CALL LOGGER.DEBUG(LOGGER_ID, 'Message "' || MSG || '"');


  IF (CUR_SCHEMA IS NULL OR REPORTS_TABLE IS NULL) THEN
   IF (EXEC_ID IS NULL) THEN
    SET EXEC_ID = -1;
    SET EXEC_ID_COPY = EXEC_ID;
   END IF;
   INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
     VALUES (CURRENT TIMESTAMP, EXEC_ID, -1, 'Invalid parameters');
  ELSE
   SET MSG = ESCAPE_QUOTES(MSG);
   SET SENTENCE = 'INSERT INTO ' || CUR_SCHEMA || '.' || REPORTS_TABLE
     || ' (DATE, EXECUTION_ID, TEST_NAME, MESSAGE) VALUES ('
     || 'CURRENT TIMESTAMP, ' || COALESCE(EXEC_ID, -1) || ', '''
     || COALESCE(TESTNAME, '') || ''', ''' || COALESCE(MSG, 'NULL') || ''')';
   CALL LOGGER.DEBUG(LOGGER_ID, 'Sentence: ' || SENTENCE);
   PREPARE STMT FROM SENTENCE;
   EXECUTE STMT;
  END IF;

  COMMIT;

  CALL LOGGER.INFO(LOGGER_ID, '<');
 END P_WRITE_IN_REPORT_BODY @

/**
 * Write a message in the tests' report. Autonomous.
 *
 * IN MSG
 *   Message to insert in the report.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE WRITE_IN_REPORT_AUTONOMOUS (
  IN MSG ANCHOR REPORT_TESTS.MESSAGE
  )
  LANGUAGE SQL
  SPECIFIC P_WRITE_IN_REPORT_AUTONOMOUS
  DYNAMIC RESULT SETS 0
  AUTONOMOUS -- Autonomous transactions, it means it writes anyway.
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_WRITE_IN_REPORT_AUTONOMOUS: BEGIN
  DECLARE LOGGER_ID SMALLINT;

  CALL LOGGER.GET_LOGGER('DB2UNIT_1.DB2UNIT.WRITE_IN_REPORT_AUTONOMOUS',
    LOGGER_ID);

  CALL LOGGER.INFO(LOGGER_ID, 'It got into an autonomous transaction');

  CALL WRITE_IN_REPORT_BODY(MSG);
 END P_WRITE_IN_REPORT_AUTONOMOUS @

/**
 * Write a message in the tests' report. Dispatcher between autonomous or not.
 *
 * IN MSG
 *   Message to insert in the report.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE WRITE_IN_REPORT (
  IN MSG ANCHOR REPORT_TESTS.MESSAGE
  )
  LANGUAGE SQL
  SPECIFIC P_WRITE_IN_REPORT
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_WRITE_IN_REPORT: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE AUTONOMOUS_ERROR CONDITION FOR SQLSTATE '560D2';
  DECLARE CONTINUE HANDLER FOR AUTONOMOUS_ERROR
    BEGIN
     INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
       VALUES (CURRENT TIMESTAMP, EXEC_ID, -2, 'Autonomous error in '
       || 'WRITE_IN_REPORT');
     CALL LOGGER.FATAL(LOGGER_ID, 'Autonomous error in WRITE_IN_REPORT');
    END;

  CALL LOGGER.GET_LOGGER('DB2UNIT_1.DB2UNIT.WRITE_IN_REPORT', LOGGER_ID);

  IF (AUTONOMOUS_EXEC = TRUE) THEN
   CALL LOGGER.WARN(LOGGER_ID, 'It will get into an autonomous transaction');
   CALL WRITE_IN_REPORT_AUTONOMOUS(MSG);
  ELSE
   CALL WRITE_IN_REPORT_BODY(MSG);
  END IF;
 END P_WRITE_IN_REPORT @

/**
 * Sorts the procedures list.
 *
 * IN PREV_EXEC_ID
 *   Previous execution ID to run the tests in that same order. Useful when
 *   tests were executed randomly and generate an error.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE SORT_PROC_NAMES (
  IN PREV_EXEC_ID ANCHOR EXECUTION_REPORTS.EXECUTION_ID DEFAULT NULL
  )
  LANGUAGE SQL
  SPECIFIC P_SORT_PROC_NAMES
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_SORT_PROC_NAMES: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE NEW_LIST PROCS_NAMES_TYPE;
  DECLARE INDEX INT;
  DECLARE LENGTH SMALLINT;
  DECLARE POS INT;
  DECLARE PROC_NAME ANCHOR SYSCAT.PROCEDURES.PROCNAME;

  CALL LOGGER.GET_LOGGER('DB2UNIT_1.DB2UNIT.SORT_PROC_NAMES', LOGGER_ID);
  CALL LOGGER.INFO(LOGGER_ID, '>');

  IF (PREV_EXEC_ID IS NULL AND RANDOM_SORT = FALSE) THEN
   CALL LOGGER.INFO(LOGGER_ID, 'No random');
  ELSEIF (PREV_EXEC_ID IS NULL AND RANDOM_SORT = TRUE) THEN
   CALL LOGGER.INFO(LOGGER_ID, 'Random');
   SET INDEX = 1;
   SET LENGTH = CARDINALITY(PROCS_NAMES);
   WHILE (INDEX <= LENGTH) DO
    -- Looks for an empty space
    BEGIN
     DECLARE ARRAY_ERROR CONDITION FOR SQLSTATE '2202E';
     DECLARE EXIT HANDLER FOR ARRAY_ERROR SET PROC_NAME = NULL;
     SET POS = RAND() * LENGTH + 1;
     SET PROC_NAME = NEW_LIST[POS];
     WHILE (PROC_NAME IS NOT NULL) DO
      CALL LOGGER.DEBUG(LOGGER_ID, 'Try ' || POS);
      SET POS = RAND() * LENGTH + 1;
      SET PROC_NAME = NEW_LIST[POS];
     END WHILE;
    END;
    CALL LOGGER.DEBUG(LOGGER_ID, 'Iteration ' || INDEX || ' position ' || POS);

    SET NEW_LIST[POS] = PROCS_NAMES[INDEX];
    SET INDEX = INDEX + 1;
   END WHILE;
   SET PROCS_NAMES = NEW_LIST;
  ELSE
   SET PROCS_NAMES = (
     SELECT ARRAY_AGG(TEST_NAME ORDER BY POSITION)
     FROM SORTS
     WHERE SUITE_NAME = CUR_SCHEMA
     AND EXECUTION_ID = PREV_EXEC_ID);
   CALL LOGGER.DEBUG(LOGGER_ID, 'Elements ' || CARDINALITY(PROCS_NAMES));
  END IF;

  CALL LOGGER.INFO(LOGGER_ID, '<' );
 END P_SORT_PROC_NAMES @

/**
 * Writes the order of the list in a table for future reference.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE SAVE_LIST (
  )
  LANGUAGE SQL
  SPECIFIC P_SAVE_LIST
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_SAVE_LIST: BEGIN
  INSERT INTO SORTS
    SELECT CUR_SCHEMA, EXEC_ID, POSITION, TEST_NAME
    FROM UNNEST(PROCS_NAMES) WITH ORDINALITY AS (TEST_NAME, POSITION);
 END P_SAVE_LIST @

/**
 * Register the message of a test. Useful when a test is executed without
 * calling assertion, but it fails anyway.
 *
 * IN MESSAGE
 *   Related message to the test.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE REGISTER_MESSAGE(
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT
  )
  LANGUAGE SQL
  SPECIFIC P_REGISTER_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_REGISTER_MESSAGE: BEGIN
  IF (MESSAGE IS NULL) THEN
   SET TEST_MESSAGE = '';
  ELSE
   SET TEST_MESSAGE = MESSAGE;
  END IF;
 END P_REGISTER_MESSAGE @

/**
 * Execute a procedure without parameters. Implementation.
 *
 * IN PROC_NAME
 *   Name of the stored procedure.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE EXEC_PROCEDURE_BODY (
  IN PROC_NAME ANCHOR SYSCAT.PROCEDURES.PROCNAME
  )
  LANGUAGE SQL
  SPECIFIC P_EXEC_PROCEDURE_BODY
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_EXEC_PROCEDURE_BODY: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  -- To keep the generated error.
  DECLARE SQLCODE INTEGER DEFAULT 0;
  DECLARE SQLSTATE CHAR(5) DEFAULT '00000';

  DECLARE MSG_TEXT ANCHOR MAX_SIGNAL.SIGNAL; -- Message from signal.
  DECLARE SENTENCE ANCHOR MAX_VALUES.SENTENCE; -- Dynamic statement
    -- to execute.
  DECLARE INEXISTENT CONDITION FOR SQLSTATE '42884';
  DECLARE TOO_LONG CONDITION FOR SQLSTATE '22001';
  DECLARE STMT STATEMENT; -- Statement to execute.
  -- If the procedure does not exist, then exist without any message.
  DECLARE EXIT HANDLER FOR INEXISTENT
    CALL LOGGER.INFO(LOGGER_ID, '<');
  -- A string is too long to be processed.
  DECLARE EXIT HANDLER FOR TOO_LONG
    BEGIN
     DECLARE COPY_SQLSTATE CHAR(5);
     GET DIAGNOSTICS EXCEPTION 1 MSG_TEXT = MESSAGE_TEXT;
     SET COPY_SQLSTATE = SQLSTATE;
     CALL WRITE_IN_REPORT(SUBSTR('String too long: "' || COALESCE(MSG_TEXT,
       'No message') || '"', 1, 512));
     CALL LOGGER.INFO(LOGGER_ID, '< String too long ' || COALESCE(COPY_SQLSTATE,
       'EMPTY') || '-' || COALESCE(MSG_TEXT, 'No message'));
     SET TEST_RESULT = RESULT_ERROR;
     COMMIT;
    END;
  -- Logs any exception or warning.
  DECLARE EXIT HANDLER FOR SQLWARNING
    BEGIN
     DECLARE COPY_SQLSTATE CHAR(5);
     DECLARE COPY_SQLCODE INTEGER;
     GET DIAGNOSTICS EXCEPTION 1 MSG_TEXT = MESSAGE_TEXT;
     SET COPY_SQLSTATE = SQLSTATE, COPY_SQLCODE = SQLCODE;
     CALL WRITE_IN_REPORT(TEST_MESSAGE);
     CALL WRITE_IN_REPORT(SUBSTR('Warning: SQLCode' || COALESCE(COPY_SQLCODE,
       -1) || '-SQLState' || COALESCE(COPY_SQLSTATE, 'EMPTY') || '-'
       || COALESCE(MSG_TEXT, 'No message'), 1, 512));
     CALL LOGGER.INFO(LOGGER_ID, '< With warning ' || COALESCE(COPY_SQLSTATE,
       'EMPTY') || '-' || COALESCE(COPY_SQLCODE, -1) || TEST_MESSAGE);
     SET TEST_RESULT = RESULT_ERROR;
     COMMIT;
    END;
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
     DECLARE COPY_SQLSTATE CHAR(5);
     DECLARE COPY_SQLCODE INTEGER;
     GET DIAGNOSTICS EXCEPTION 1 MSG_TEXT = MESSAGE_TEXT;
     SET COPY_SQLSTATE = SQLSTATE, COPY_SQLCODE = SQLCODE;
     CALL WRITE_IN_REPORT(TEST_MESSAGE);
     CALL WRITE_IN_REPORT(SUBSTR('Exception(2): SQLCode' || COALESCE(
       COPY_SQLCODE, -1) || '-SQLState' || COALESCE(COPY_SQLSTATE, 'EMPTY') 
       || '-' || COALESCE(MSG_TEXT, 'No message'), 1, 512));
     CALL LOGGER.INFO(LOGGER_ID, '< With exception ' || COALESCE(COPY_SQLSTATE,
       'EMPTY') || '-' || COALESCE(COPY_SQLCODE, -1) || TEST_MESSAGE);
     SET TEST_RESULT = RESULT_ERROR;
     COMMIT;
    END;

  CALL LOGGER.GET_LOGGER('DB2UNIT_1.DB2UNIT.EXEC_PROCEDURE_BODY', LOGGER_ID);
  CALL LOGGER.INFO(LOGGER_ID, '>' || COALESCE(PROC_NAME, 'NoName'));

  IF (PROC_NAME IS NOT NULL) THEN
   SET SENTENCE = 'CALL ' || CUR_SCHEMA || '.' || PROC_NAME || '()';
   CALL LOGGER.DEBUG(LOGGER_ID, 'Sentence: ' || SENTENCE);
   PREPARE STMT FROM SENTENCE;
   EXECUTE STMT;
  ELSE
   CALL LOGGER.ERROR(LOGGER_ID, 'Null procedure name');
  END IF;

  CALL LOGGER.INFO(LOGGER_ID, '<');
  COMMIT;
 END P_EXEC_PROCEDURE_BODY @

/**
 * Execute a procedure without parameters. Autonomous.
 *
 * IN PROC_NAME
 *   Name of the stored procedure.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE EXEC_PROCEDURE_AUTONOMOUS (
  IN PROC_NAME ANCHOR SYSCAT.PROCEDURES.PROCNAME
  )
  LANGUAGE SQL
  SPECIFIC P_EXEC_PROCEDURE_AUTONOMOUS
  DYNAMIC RESULT SETS 0
  AUTONOMOUS -- Autonomous transactions, it means it writes anyway.
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_EXEC_PROCEDURE_AUTONOMOUS: BEGIN
  DECLARE LOGGER_ID SMALLINT;

  CALL LOGGER.GET_LOGGER('DB2UNIT_1.DB2UNIT.EXEC_PROCEDURE_AUTONOMOUS',
    LOGGER_ID);

  CALL LOGGER.INFO(LOGGER_ID, 'It got into an autonomous transaction for '
    || COALESCE(PROC_NAME, '?'));

  CALL EXEC_PROCEDURE_BODY(PROC_NAME);
 END P_EXEC_PROCEDURE_AUTONOMOUS @

/**
 * Execute a procedure without parameters. Dispatcher between autonomous or not.
 *
 * IN PROC_NAME
 *   Name of the stored procedure.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE EXEC_PROCEDURE (
  IN PROC_NAME ANCHOR SYSCAT.PROCEDURES.PROCNAME
  )
  LANGUAGE SQL
  SPECIFIC P_EXEC_PROCEDURE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_EXEC_PROCEDURE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE AUTONOMOUS_ERROR CONDITION FOR SQLSTATE '560D2';
  DECLARE CONTINUE HANDLER FOR AUTONOMOUS_ERROR
    BEGIN
     INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
       VALUES (CURRENT TIMESTAMP, EXEC_ID, -3, 'Autonomous error in '
       || 'EXEC_PROCEDURE');
     CALL LOGGER.FATAL(LOGGER_ID, 'Autonomous error in EXEC_PROCEDURE for '
       || COALESCE(PROC_NAME, '?'));
    END;

  CALL LOGGER.GET_LOGGER('DB2UNIT_1.DB2UNIT.EXEC_PROCEDURE', LOGGER_ID);

  IF (AUTONOMOUS_EXEC = TRUE) THEN
   CALL LOGGER.WARN(LOGGER_ID, 'It will get into an autonomous transaction for '
     || COALESCE(PROC_NAME, '?'));
   CALL EXEC_PROCEDURE_AUTONOMOUS(PROC_NAME);
  ELSE
   CALL EXEC_PROCEDURE_BODY(PROC_NAME);
  END IF;
 END P_EXEC_PROCEDURE @

/**
 * Performs the execution of the tests.
 *
 * INOUT CURRENT_STATUS
 *   Current status of the global execution.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE EXECUTION (
  INOUT CURRENT_STATUS ANCHOR EXECUTION_REPORTS.STATUS
  )
  LANGUAGE SQL
  SPECIFIC P_EXECUTION
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_EXECUTION: BEGIN
  -- To keep the generated error.
  DECLARE SQLCODE INTEGER DEFAULT 0;
  DECLARE SQLSTATE CHAR(5) DEFAULT '00000';

  DECLARE LOGGER_ID SMALLINT;
  DECLARE CARD_PROCS INT; -- Quantity of procedures.
  DECLARE INDEX INT; -- Index to scan the procs.
  DECLARE START_TIME TIMESTAMP; -- Start time of the execution.
  DECLARE SECONDS ANCHOR REPORT_TESTS.TIME; -- To count the expended
    -- time.
  DECLARE SENTENCE ANCHOR MAX_VALUES.SENTENCE; -- Dynamic statement
    -- to execute.

  -- For tests summary
  DECLARE TESTS_EXEC SMALLINT DEFAULT 0;
  DECLARE TESTS_PASSED SMALLINT DEFAULT 0;
  DECLARE TESTS_FAILED SMALLINT DEFAULT 0;
  DECLARE TESTS_ERROR SMALLINT DEFAULT 0;
  DECLARE RET INTEGER DEFAULT 0;
  DECLARE DATETIME_OVERFLOW CONDITION FOR SQLSTATE '22008';

  DECLARE STMT STATEMENT; -- Statement to execute.

  -- When the milliseconds conversion cannot be made.
  DECLARE CONTINUE HANDLER FOR DATETIME_OVERFLOW
    BEGIN
     SET SENTENCE = 'UPDATE ' || CUR_SCHEMA || '.' || REPORTS_TABLE || ' '
       || 'SET TIME = -1 '
       || 'WHERE MESSAGE = ''Executing ' || COALESCE(TESTNAME, 'NULL') || ''' '
       || 'AND EXECUTION_ID = ' || EXEC_ID;
     PREPARE STMT FROM SENTENCE;
     EXECUTE STMT;
    END;
  DECLARE CONTINUE HANDLER FOR SQLWARNING
    BEGIN
     DECLARE COPY_SQLSTATE CHAR(5);
     DECLARE COPY_SQLCODE INTEGER;
     SET COPY_SQLSTATE = SQLSTATE, COPY_SQLCODE = SQLCODE;
     INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
       VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS, 'Warning: SQLCode'
       || COALESCE(COPY_SQLCODE, -1) || '-SQLState' || COALESCE(COPY_SQLSTATE,
       'EMPTY'));
     CALL LOGGER.INFO(LOGGER_ID, 'Warning ' || COALESCE(COPY_SQLSTATE,
       'EMPTY') || '-' || COALESCE(COPY_SQLCODE, -1));
    END;
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
     DECLARE COPY_SQLSTATE CHAR(5);
     DECLARE COPY_SQLCODE INTEGER;
     SET COPY_SQLSTATE = SQLSTATE, COPY_SQLCODE = SQLCODE;
     INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
       VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS,
       'Exception(3): SQLCode' || COALESCE(COPY_SQLCODE, -1) || '-SQLState'
       || COALESCE(COPY_SQLSTATE, 'EMPTY'));
     CALL LOGGER.INFO(LOGGER_ID, 'Exception ' || COALESCE(COPY_SQLSTATE,
       'EMPTY') || '-' || COALESCE(COPY_SQLCODE, -1));
    END;

  CALL LOGGER.GET_LOGGER('DB2UNIT_1.DB2UNIT.EXECUTION', LOGGER_ID);
  CALL LOGGER.WARN(LOGGER_ID, '>');

  COMMIT;

  -- BEFORE SUITE
  SET CURRENT_STATUS = 'Executing.BeforeSuite';
  CALL LOGGER.INFO(LOGGER_ID, CURRENT_STATUS);
  SET TESTNAME = 'Before Suite';
  CALL WRITE_IN_REPORT('Starting execution');
  CALL EXEC_PROCEDURE(ONE_TIME_SETUP);
  COMMIT;

  SET CARD_PROCS = CARDINALITY(PROCS_NAMES);
  SET INDEX = 1;
  WHILE (INDEX <= CARD_PROCS) DO

   -- BEFORE
   SET CURRENT_STATUS = 'Executing.Before';
   CALL LOGGER.INFO(LOGGER_ID, CURRENT_STATUS);
   SET TESTNAME = PROCS_NAMES[INDEX];
   CALL WRITE_IN_REPORT(SUBSTR('Executing ' || COALESCE(TESTNAME, 'NULL'), 1,
     128));
   CALL EXEC_PROCEDURE(SETUP);
   COMMIT;

   -- TEST
   SET CURRENT_STATUS = 'Executing.Test';
   CALL LOGGER.INFO(LOGGER_ID, CURRENT_STATUS);
   SET START_TIME = CURRENT TIMESTAMP;
   CALL EXEC_PROCEDURE(TESTNAME);
   SET SECONDS = TIMESTAMPDIFF(1, CURRENT TIMESTAMP - START_TIME);

   IF (TEST_RESULT IS NULL) THEN
    SET TEST_RESULT = RESULT_PASSED;
   END IF;
   -- Update the stats
   SET TESTS_EXEC = TESTS_EXEC + 1;
   IF (TEST_RESULT = RESULT_PASSED) THEN
    SET TESTS_PASSED = TESTS_PASSED + 1;
   ELSEIF (TEST_RESULT = RESULT_FAILED) THEN
    SET TESTS_FAILED = TESTS_FAILED + 1;
   ELSEIF (TEST_RESULT = RESULT_ERROR) THEN
    SET TESTS_ERROR = TESTS_ERROR + 1;
   END IF;

   SET SENTENCE = 'UPDATE ' || CUR_SCHEMA || '.' || REPORTS_TABLE || ' '
     || 'SET TIME = ' || SECONDS || ', '
     || 'FINAL_STATE = ''' || TEST_RESULT || ''' '
     || 'WHERE MESSAGE = ''Executing ' || COALESCE(TESTNAME, 'NULL') || ''' '
     || 'AND EXECUTION_ID = ' || EXEC_ID;
   SET TEST_RESULT = NULL;
   SET TEST_MESSAGE = NULL;
   PREPARE STMT FROM SENTENCE;
   EXECUTE STMT;
   COMMIT;

   -- AFTER
   SET CURRENT_STATUS = 'Executing.After';
   CALL LOGGER.INFO(LOGGER_ID, CURRENT_STATUS);
   CALL EXEC_PROCEDURE(TEAR_DOWN);
   SET TESTNAME = NULL;
   COMMIT;

   SET INDEX = INDEX + 1;
  END WHILE;

  -- AFTER SUITE
  SET CURRENT_STATUS = 'Executing.AfterSuite';
  SET TESTNAME = 'After Suite';
  CALL LOGGER.INFO(LOGGER_ID, CURRENT_STATUS);
  CALL EXEC_PROCEDURE(ONE_TIME_TEAR_DOWN);
  CALL WRITE_IN_REPORT('Finishing execution');
  SET TESTNAME = NULL;
  COMMIT;

 -- Write a summary
  CALL WRITE_IN_REPORT (TESTS_EXEC || ' tests were executed');
  CALL WRITE_IN_REPORT (TESTS_PASSED || ' tests passed');
  CALL WRITE_IN_REPORT (TESTS_FAILED || ' tests failed');
  CALL WRITE_IN_REPORT (TESTS_ERROR || ' tests with errors');

  -- Return value
  IF (TESTS_ERROR > 0 OR TESTS_FAILED > 0) THEN
   SET RET = 1;
  END IF;

  CALL LOGGER.WARN(LOGGER_ID, '<');

  RETURN RET;
 END P_EXECUTION @

/**
 * Process the name of a schema, by adding extra spaces when the size is less
 * than 8.
 *
 * IN SCHEMA_NAME
 *   Name of the schema to process.
 * RETURN the same name of the schema with extra space in order to be at least
 *   8 chars length.
 */
ALTER MODULE DB2UNIT ADD
  FUNCTION PROCESS_SCHEMA (
  IN SCHEMA_NAME ANCHOR SYSCAT.SCHEMATA.SCHEMANAME
  ) RETURNS ANCHOR SYSCAT.SCHEMATA.SCHEMANAME
  LANGUAGE SQL
  SPECIFIC F_PROCESS_SCHEMA
  DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 F_PROCESS_SCHEMA : BEGIN
  DECLARE SIZE SMALLINT;
  SET SIZE = LENGTH(SCHEMA_NAME);
  WHILE (SIZE < 8) DO
   SET SCHEMA_NAME = SCHEMA_NAME || ' ';
   SET SIZE = LENGTH(SCHEMA_NAME);
  END WHILE;
  RETURN SCHEMA_NAME;
 END F_PROCESS_SCHEMA @

/**
 * Returns a random number for the execution ID.
 *
 * RETURN a unique number for the execution ID.
 */
ALTER MODULE DB2UNIT publish
  FUNCTION GET_RANDOM_ID (
  ) RETURNS ANCHOR EXECUTIONS.EXECUTION_ID
  LANGUAGE SQL
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  SPECIFIC F_GET_RANDOM_ID
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 F_GET_RANDOM_ID : BEGIN
  DECLARE TIME TIMESTAMP;
  DECLARE IGNORED DOUBLE;
  DECLARE RET ANCHOR EXECUTIONS.EXECUTION_ID;
  DECLARE RETRY BOOLEAN DEFAULT TRUE;

  DECLARE LOGGER_ID SMALLINT;

  CALL LOGGER.GET_LOGGER('DB2UNIT_1.DB2UNIT.GET_RANDOM_ID', LOGGER_ID);
  CALL LOGGER.WARN(LOGGER_ID, '>');

  IF (SEED IS NULL) THEN
   SET TIME = CURRENT_TIMESTAMP;
   SET SEED = (BIGINT(MINUTE(TIME)) * 60 + SECOND(TIME)) * 1000000
      + MICROSECOND(time);
   SET IGNORED = RAND(INTEGER(MOD(SEED, 2147483648)));
  END IF;

  WHILE (RETRY = TRUE) DO
   SET RET = RAND() * 100000;
   CALL LOGGER.WARN(LOGGER_ID, 'Value ' || RET);
   BEGIN
    DECLARE EXISTING_ID CONDITION FOR SQLSTATE '23505';
    DECLARE EXIT HANDLER FOR EXISTING_ID
      SET RETRY = TRUE;
     INSERT INTO EXECUTIONS (EXECUTION_ID) VALUES (RET);
    SET RETRY = FALSE;
   END;
  END WHILE;

  CALL LOGGER.WARN(LOGGER_ID, '<');

  RETURN RET;
 END F_GET_RANDOM_ID @

/**
 * Execute the tests defined in a set of stored procedure in the given schema.
 * PREV_EXEC_ID and TEST_NAME cannot be passed at the same time.
 *
 * IN SCHEMA_NAME
 *   Name of the schema where the stored procedures for tests are stored.
 * IN PREV_EXEC_ID
 *   Previous execution ID to run the tests in that same order. Useful when
 *   tests were executed randomly and generate an error.
 * IN TEST_NAME
 *   Procedure to execute. If null, all tests of the given schema are
 *   executed.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE RUN_SUITE (
  IN SCHEMA_NAME ANCHOR SYSCAT.SCHEMATA.SCHEMANAME DEFAULT NULL,
  IN PREV_EXEC_ID ANCHOR EXECUTION_REPORTS.EXECUTION_ID DEFAULT NULL,
  IN TEST_NAME ANCHOR SYSCAT.PROCEDURES.PROCNAME DEFAULT NULL
  )
  LANGUAGE SQL
  SPECIFIC P_RUN_SUITE
  DYNAMIC RESULT SETS 2
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_RUN_SUITE: BEGIN
  -- To keep the generated error.
  DECLARE SQLCODE INTEGER DEFAULT 0;
  DECLARE SQLSTATE CHAR(5) DEFAULT '00000';
  DECLARE MSG_TEXT ANCHOR MAX_SIGNAL.SIGNAL; -- Message from signal.

  DECLARE LOGGER_ID SMALLINT;
  DECLARE CURRENT_STATUS ANCHOR EXECUTION_REPORTS.STATUS; -- Internal status.
  DECLARE CONTINU BOOLEAN DEFAULT TRUE; -- Stops the execution.
  DECLARE SENTENCE ANCHOR MAX_VALUES.SENTENCE; -- Dynamic statement
    -- to execute.
  DECLARE TABLENAME ANCHOR SYSCAT.TABLES.TABNAME; -- Name of the table.
  DECLARE REPORT_CREATED BOOLEAN DEFAULT FALSE; -- If a report was created.
  DECLARE PREVIOUS_SCHEMA ANCHOR SYSCAT.SCHEMATA.SCHEMANAME; -- Previous schema
    -- to test itself.
  DECLARE PREVIOUS_TESTNAME ANCHOR SYSCAT.PROCEDURES.PROCNAME; -- Previous test
    -- name to test itself.
  DECLARE PREVIOUS_EXEC_ID ANCHOR EXECUTION_REPORTS.EXECUTION_ID; -- Previous
    -- exec id to test itself.
  DECLARE PREVIOUS_PROCS_NAMES PROCS_NAMES_TYPE; -- Previous list.
  DECLARE INIT_TIME TIMESTAMP;
  DECLARE PROC_NAME_FOUND ANCHOR SYSCAT.PROCEDURES.PROCNAME; -- If the given
    -- test name does not exist.
  DECLARE RET INTEGER DEFAULT 0;

  DECLARE EXISTING_LOCK CONDITION FOR SQLSTATE '23505';
  DECLARE STMT STATEMENT; -- Statement to execute.

  DECLARE GLOBAL_REPORT_CURSOR CURSOR
    WITH RETURN TO CALLER
    FOR GLOBAL_REPORT_RS;
  DECLARE REPORT_CURSOR CURSOR
    WITH RETURN TO CLIENT
    FOR REPORT_RS;
  DECLARE CONTINUE HANDLER FOR EXISTING_LOCK
    BEGIN
     INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
       VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS, 'There is another '
       || 'concurrent execution on of the same test suite.');
     INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
       VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS, 'If not, please '
       || 'execute CALL DB2UNIT.RELEASE_LOCK(''' || COALESCE(SCHEMA_NAME,
       'SUITE_NAME') || ''')');
     CALL LOGGER.WARN(LOGGER_ID, 'There is another concurrent execution of the '
       || 'same test suite');
     SET CONTINU = FALSE;
    END;
  DECLARE EXIT HANDLER FOR SQLWARNING
    BEGIN
     DECLARE COPY_SQLSTATE CHAR(5);
     DECLARE COPY_SQLCODE INTEGER;
     SET COPY_SQLSTATE = SQLSTATE, COPY_SQLCODE = SQLCODE;
     INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
       VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS, 'Warning: SQLCode'
       || COALESCE(COPY_SQLCODE, -1) || '-SQLState' || COALESCE(COPY_SQLSTATE,
       'EMPTY'));
     CALL LOGGER.WARN(LOGGER_ID, '< with warning ' || COALESCE(COPY_SQLSTATE,
       'EMPTY'));
    END;
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
     DECLARE COPY_SQLSTATE CHAR(5);
     DECLARE COPY_SQLCODE INTEGER;
     DECLARE LOGS_CURSOR CURSOR
       WITH RETURN TO CLIENT
       FOR LOGS_RS;
     SET COPY_SQLSTATE = SQLSTATE, COPY_SQLCODE = SQLCODE;
     GET DIAGNOSTICS EXCEPTION 1 MSG_TEXT = MESSAGE_TEXT;
     INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
       VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS,
       'Exception(4): SQLCode' || COALESCE(COPY_SQLCODE, -1) || '-SQLState'
       || COALESCE(COPY_SQLSTATE, 'EMPTY'));
     SET SENTENCE = 'SELECT MESSAGE '
       || 'FROM LOGS '
       || 'WHERE DATE = (SELECT MAX(DATE) FROM LOGS)';
     PREPARE LOGS_RS FROM SENTENCE;
     CALL LOGGER.WARN(LOGGER_ID, '< with exception SQLCode'
       || COALESCE(COPY_SQLCODE, -1) || '-SQLState' || COALESCE(COPY_SQLSTATE,
       'EMPTY') || '-' || COALESCE(MSG_TEXT, 'No message'));
     OPEN LOGS_CURSOR;
    END;

  CALL LOGGER.GET_LOGGER('DB2UNIT_1.DB2UNIT.RUN_SUITE', LOGGER_ID);
  CALL LOGGER.WARN(LOGGER_ID, '>');
  SET INIT_TIME = CURRENT TIMESTAMP;

  -- INITIALIZATION
  -- Set the initial status
  SET CURRENT_STATUS = 'Initialization';
  CALL LOGGER.INFO(LOGGER_ID, 'Execution for ' || COALESCE(SCHEMA_NAME,
    'NULL schema'));
  CALL LOGGER.INFO(LOGGER_ID, CURRENT_STATUS);

  -- Check previous values (for self testing)
  IF (CUR_SCHEMA IS NOT NULL) THEN
   SET PREVIOUS_EXEC_ID = EXEC_ID;
   SET PREVIOUS_SCHEMA = CUR_SCHEMA;
   SET CUR_SCHEMA = NULL;
   SET PREVIOUS_TESTNAME = TESTNAME;
   SET PREVIOUS_PROCS_NAMES = PROCS_NAMES;
   SET PROCS_NAMES = NULL;
   CALL LOGGER.INFO(LOGGER_ID, 'Self testing values');
  END IF;

  SET EXEC_ID = GET_RANDOM_ID();
  SET EXEC_ID_COPY = EXEC_ID;
  CALL LOGGER.INFO(LOGGER_ID, 'EXEC_ID: ' || EXEC_ID);

  -- Check input values.
  IF (PREV_EXEC_ID IS NOT NULL AND TEST_NAME IS NOT NULL) THEN
   INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
     VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS, TRIM(SUBSTR('Previous '
     || 'execution ID (PREV_EXEC_ID) and a test name (TEST_NAME) were given ('
     || PREV_EXEC_ID || ', ' || TEST_NAME || ')', 1, 128)));
   CALL LOGGER.INFO(LOGGER_ID, 'Previous execution ID (PREV_EXEC_ID) and a '
     || 'test name (TEST_NAME) were given (' || PREV_EXEC_ID || ', '
     || TEST_NAME || ')');
   SET CONTINU = FALSE;
  END IF;

  IF (CONTINU = TRUE) THEN
   IF (SCHEMA_NAME IS NULL) THEN
    SET SCHEMA_NAME = CURRENT SCHEMA;
   END IF;
   SET SCHEMA_NAME = PROCESS_SCHEMA(SCHEMA_NAME);
   MERGE INTO SUITES AS IN
     USING (VALUES (SCHEMA_NAME)) AS EX (SUITE_NAME)
     ON (IN.SUITE_NAME = EX.SUITE_NAME)
     WHEN NOT MATCHED THEN
     INSERT (SUITE_NAME) VALUES (EX.SUITE_NAME)
     ELSE IGNORE;

   -- Validates the schema
   SET CUR_SCHEMA = (SELECT TRIM(SCHEMANAME)
     FROM SYSCAT.SCHEMATA
     WHERE SCHEMANAME = PROCESS_SCHEMA(SCHEMA_NAME));
   IF (CUR_SCHEMA IS NULL) THEN
    SET CUR_SCHEMA = (SELECT TRIM(SCHEMANAME)
      FROM SYSCAT.SCHEMATA
      WHERE SCHEMANAME = PROCESS_SCHEMA(UPPER(SCHEMA_NAME)));
    IF (CUR_SCHEMA IS NULL) THEN
     INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
       VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS, SUBSTR(
       'The given schema does not exists: ' || COALESCE(SCHEMA_NAME, 'NULL'), 1,
       128));
     CALL LOGGER.DEBUG(LOGGER_ID, 'The given schema does not exists');
     SET CONTINU = FALSE;
    END IF;
   ELSE
    -- Puts the lock for the current suite.
    INSERT INTO SUITE_LOCKS (NAME) VALUES (SCHEMA_NAME);
    INSERT INTO SUITES_EXECUTIONS (SUITE_NAME, EXECUTION_ID)
      VALUES (SCHEMA_NAME, EXEC_ID);

    -- If there is not another execution of the same test suite.
    IF (CONTINU = TRUE) THEN
     CALL LOGGER.INFO(LOGGER_ID, CUR_SCHEMA || ':' || EXEC_ID);
     INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
       VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS, LICENSE);
     INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
       VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS, SUBSTR('Execution '
       || 'of ' || CUR_SCHEMA || ' with ID ' || EXEC_ID, 1, 128));
    END IF;
   END IF;
  END IF;

  -- PREPARE REPORT
  -- Creates the report's table if it does not exist.
  IF (CONTINU = TRUE) THEN
   SET CURRENT_STATUS = 'Prepare Report';
   CALL LOGGER.INFO(LOGGER_ID, CURRENT_STATUS);

   SET TABLENAME = (SELECT TABNAME
     FROM SYSCAT.TABLES
     WHERE TABSCHEMA = PROCESS_SCHEMA(CUR_SCHEMA)
     AND TABNAME = REPORTS_TABLE);
   -- Create the table only if it does not exist.
   IF (TABLENAME IS NULL) THEN
    SET SENTENCE = 'CREATE TABLE ' || CUR_SCHEMA || '.' || REPORTS_TABLE
      || ' LIKE ' || UTILITY_SCHEMA || '.' || REPORTS_TABLE;
    CALL LOGGER.DEBUG(LOGGER_ID, 'Sentence: ' || SENTENCE);
    PREPARE STMT FROM SENTENCE;
    EXECUTE STMT;
    INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
      VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS, SUBSTR(
      'The reports table created: ' || CUR_SCHEMA || '.' || REPORTS_TABLE, 1,
      128));
    CALL LOGGER.INFO(LOGGER_ID, 'Table created for ' || CUR_SCHEMA);
   ELSE
    INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
      VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS, TRIM(SUBSTR(
      'The reports table already exist: ' || CUR_SCHEMA || '.'
      || REPORTS_TABLE, 1, 128)));
    CALL LOGGER.DEBUG(LOGGER_ID, 'The reports table already exist');
   END IF;
   SET SENTENCE = 'ALTER TABLE ' || CUR_SCHEMA || '.' || REPORTS_TABLE
     || ' ALTER COLUMN SUITE_NAME SET WITH DEFAULT '''
     || CUR_SCHEMA || '''';
   CALL LOGGER.DEBUG(LOGGER_ID, 'Sentence: ' || SENTENCE);
   PREPARE STMT FROM SENTENCE;
   EXECUTE STMT;
   SET REPORT_CREATED = TRUE;
  END IF;

  -- GENERATE LIST
  -- Generates the list of procedures to execute.
  IF (CONTINU = TRUE) THEN
   SET CURRENT_STATUS = 'Generate list';
   CALL LOGGER.INFO(LOGGER_ID, CURRENT_STATUS);

   IF (TEST_NAME IS NULL) THEN
    SET PROCS_NAMES = ARRAY[
      SELECT PROCNAME
      FROM SYSCAT.PROCEDURES
      WHERE PROCSCHEMA = PROCESS_SCHEMA(CUR_SCHEMA)
      AND PROCNAME LIKE 'TEST_%'
      AND LANGUAGE = 'SQL'
      AND PARM_COUNT = 0
      ORDER BY PROCNAME];
   ELSE
    SET PROC_NAME_FOUND = (SELECT PROCNAME
      FROM SYSCAT.PROCEDURES
      WHERE PROCSCHEMA = PROCESS_SCHEMA(CUR_SCHEMA)
      AND PROCNAME = TEST_NAME
      AND LANGUAGE = 'SQL'
      AND PARM_COUNT = 0);
    IF (PROC_NAME_FOUND IS NULL) THEN
     SET PROC_NAME_FOUND = (SELECT PROCNAME
       FROM SYSCAT.PROCEDURES
       WHERE PROCSCHEMA = PROCESS_SCHEMA(CUR_SCHEMA)
       AND PROCNAME = UPPER(TEST_NAME)
       AND LANGUAGE = 'SQL'
       AND PARM_COUNT = 0);
     IF (PROC_NAME_FOUND IS NOT NULL) THEN
      SET PROCS_NAMES[1] = TEST_NAME;
     ELSE
      SET CONTINU = FALSE;
      INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
        VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS, 'Test "'
        || TEST_NAME || '" does not exist in suite ' || CUR_SCHEMA);
      CALL LOGGER.ERROR(LOGGER_ID, 'Test "' || TEST_NAME
        || '" does not exist in suite ' || CUR_SCHEMA);
      CALL RELEASE_LOCK(SCHEMA_NAME);
     END IF;
    ELSE
     SET PROCS_NAMES[1] = TEST_NAME;
    END IF;
   END IF;
  END IF;

  -- SORT LIST
  -- Sort the list of procedures to execute
  IF (CONTINU = TRUE) THEN
   SET CURRENT_STATUS = 'Sort list';
   CALL LOGGER.INFO(LOGGER_ID, CURRENT_STATUS);

   CALL SORT_PROC_NAMES(PREV_EXEC_ID);
   CALL SAVE_LIST();
  END IF;

  -- EXECUTE
  -- Execute the tests.
  IF (CONTINU = TRUE) THEN
   CALL EXECUTION(CURRENT_STATUS);
   GET DIAGNOSTICS RET = DB2_RETURN_STATUS;
   SET PROCS_NAMES = NULL;
  END IF;

  IF (CONTINU = TRUE) THEN
   -- Release the lock.
   CALL RELEASE_LOCK(SCHEMA_NAME);

   -- CALCULATING TIME
   SET CURRENT_STATUS = 'Calculating time';
   CALL LOGGER.INFO(LOGGER_ID, CURRENT_STATUS);

   -- Elapsed time.
   IF (PREVIOUS_SCHEMA IS NULL) THEN
    INSERT INTO EXECUTION_REPORTS (DATE, EXECUTION_ID, STATUS, MESSAGE_REPORT)
      VALUES (CURRENT TIMESTAMP, EXEC_ID, CURRENT_STATUS, 'Total execution time '
      || 'is: ' || TIMESTAMPDIFF(2, CURRENT TIMESTAMP - INIT_TIME)
      || ' seconds');
   END IF;
  END IF;

  -- GENERATING REPORTS
  -- Generates the reports (not for self testing)
  SET CURRENT_STATUS = 'Generating reports';
  CALL LOGGER.INFO(LOGGER_ID, CURRENT_STATUS);

  -- Only create reports when no-self-testing.
  IF (PREVIOUS_SCHEMA IS NULL) THEN
   IF (REPORT_CREATED = TRUE) THEN
    SET SENTENCE = 'SELECT VARCHAR(SUBSTR(TEST_NAME, 1 , 16), 16) AS TEST, '
      || 'FINAL_STATE, TIME AS MICROSECONDS, '
      || 'VARCHAR(SUBSTR(MESSAGE, 1, 64), 64) AS MESSAGE '
      || 'FROM ' || CUR_SCHEMA || '.' || REPORTS_TABLE || ' '
      || 'WHERE EXECUTION_ID = ' || EXEC_ID || ' '
      || 'ORDER BY DATE';
    CALL LOGGER.DEBUG(LOGGER_ID, 'Sentence: ' || SENTENCE);
    PREPARE REPORT_RS FROM SENTENCE;
    OPEN REPORT_CURSOR;
   END IF;
   SET SENTENCE = 'SELECT TIME(DATE) AS TIME, EXECUTION_ID,'
     || 'VARCHAR(SUBSTR(STATUS, 1, 21), 21) AS STATUS, '
     || 'VARCHAR(SUBSTR(MESSAGE_REPORT, 1, 62), 62) AS MESSAGE '
     || 'FROM ' || UTILITY_SCHEMA || '.EXECUTION_REPORTS '
     || 'WHERE EXECUTION_ID = ' || EXEC_ID || ' '
     || 'ORDER BY DATE';
   CALL LOGGER.DEBUG(LOGGER_ID, 'Sentence: ' || SENTENCE);
   PREPARE GLOBAL_REPORT_RS FROM SENTENCE;
   OPEN GLOBAL_REPORT_CURSOR;
  END IF;

  -- CLEAN ENVIRONMENT
  -- Cleans environment.
  SET CURRENT_STATUS = 'Clean environment';
  CALL LOGGER.INFO(LOGGER_ID, CURRENT_STATUS);

  SET LAST_EXEC_ID = EXEC_ID;
  SET CUR_SCHEMA = NULL;
  SET EXEC_ID = NULL;

  -- Restore previous environment (For self testing.)
  IF (PREVIOUS_SCHEMA IS NOT NULL) THEN
   CALL LOGGER.DEBUG(LOGGER_ID, 'Reestablish previous environment');
   SET EXEC_ID = PREVIOUS_EXEC_ID;
   SET EXEC_ID_COPY = PREVIOUS_EXEC_ID;
   SET CUR_SCHEMA = PREVIOUS_SCHEMA;
   SET TESTNAME = PREVIOUS_TESTNAME;
   SET PROCS_NAMES = PREVIOUS_PROCS_NAMES;
   SET PREVIOUS_EXEC_ID = NULL;
   SET PREVIOUS_SCHEMA = NULL;
   SET PREVIOUS_TESTNAME = NULL;
   SET PREVIOUS_PROCS_NAMES = NULL;
  END IF;

  IF (CONTINU = FALSE) THEN
   SET RET = 2;
  END IF;

  CALL LOGGER.WARN(LOGGER_ID, '<');
  RETURN RET;
 END P_RUN_SUITE @

/**
 * Execute the tests defined in a set of stored procedure in the given schema.
 *
 * IN SCHEMA_NAME
 *   Name of the schema where the stored procedures for tests are stored.
 * IN PREV_EXEC_ID
 *   Previous execution ID to run the tests in that same order. Useful when
 *   tests were executed randomly and generate an error.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE RUN_SUITE (
  IN SCHEMA_NAME ANCHOR SYSCAT.SCHEMATA.SCHEMANAME,
  IN PREV_EXEC_ID ANCHOR EXECUTION_REPORTS.EXECUTION_ID DEFAULT NULL
  )
  LANGUAGE SQL
  SPECIFIC P_RUN_SUITE_ALL
  DYNAMIC RESULT SETS 2
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_RUN_SUITE_ALL: BEGIN
  DECLARE SENTENCE ANCHOR MAX_VALUES.SENTENCE; -- Dynamic statement
    -- to execute.
  DECLARE RET INTEGER DEFAULT 0;
  DECLARE STMT STATEMENT; -- Statement to execute.
  DECLARE GLOBAL_REPORT_CURSOR CURSOR
    WITH RETURN TO CALLER
    FOR GLOBAL_REPORT_RS;

  CALL RUN_SUITE(SCHEMA_NAME, PREV_EXEC_ID, NULL);
  GET DIAGNOSTICS RET = DB2_RETURN_STATUS;

  SET SENTENCE = 'SELECT TIME(DATE) AS TIME, EXECUTION_ID,'
    || 'VARCHAR(SUBSTR(STATUS, 1, 21), 21) AS STATUS, '
    || 'VARCHAR(SUBSTR(MESSAGE_REPORT, 1, 62), 62) AS MESSAGE '
    || 'FROM ' || UTILITY_SCHEMA || '.EXECUTION_REPORTS '
    || 'WHERE EXECUTION_ID = ' || EXEC_ID_COPY || ' '
    || 'ORDER BY DATE';
  PREPARE GLOBAL_REPORT_RS FROM SENTENCE;
  OPEN GLOBAL_REPORT_CURSOR;
  RETURN RET;
 END P_RUN_SUITE_ALL @

/**
 * Register a given suite in the framework. This helps to produce an output
 * of all registered suites to execute all of them.
 *
 * IN SCHEMA_NAME
 *   Name of the suite to register.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE REGISTER_SUITE (
  IN SCHEMA_NAME ANCHOR SYSCAT.SCHEMATA.SCHEMANAME
  )
  LANGUAGE SQL
  SPECIFIC P_REGISTER_SUITE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_REGISTER_SUITE: BEGIN
  DECLARE ALREADY_EXIST CONDITION FOR SQLSTATE '23505';
  DECLARE CONTINUE HANDLER FOR ALREADY_EXIST BEGIN END;
  INSERT INTO DB2UNIT_1.SUITES (SUITE_NAME) VALUES (SCHEMA_NAME);
 END P_REGISTER_SUITE @

/**
 * Returns the Execution Id of the most recent execution.
 *
 * RETURNS ExecID of the execution Id.
 */
ALTER MODULE DB2UNIT ADD
  FUNCTION GET_LAST_EXEC_ID (
  ) RETURNS ANCHOR EXECUTION_REPORTS.EXECUTION_ID
 F_GET_LAST_EXEC_ID: BEGIN
  RETURN LAST_EXEC_ID;
 END F_GET_LAST_EXEC_ID @

/**
 * Cleans the environment, if a previous execution did not finished correctly.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE CLEAN (
  )
  LANGUAGE SQL
  SPECIFIC P_CLEAN
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_CLEAN: BEGIN
  SET CUR_SCHEMA = NULL;
  SET EXEC_ID = NULL;
  SET LAST_EXEC_ID = NULL;
  SET TESTNAME = NULL;
 END P_CLEAN @

/**
 * Cleans the last test execution. This is useful for self-testing.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE CLEAN_TEST_RESULT (
  )
  LANGUAGE SQL
  SPECIFIC P_CLEAN_TEST_RESULT
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_CLEAN_TEST_RESULT: BEGIN
  SET TEST_RESULT = NULL;
  SET TEST_MESSAGE = NULL;
 END P_CLEAN_TEST_RESULT @

/**
 * Deletes the content of all tables in this framework.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE RESET_TABLES (
  )
  LANGUAGE SQL
  SPECIFIC P_RESET_TABLES
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_RESET_TABLES: BEGIN
  DECLARE AT_END BOOLEAN; -- End of the cursor.
  DECLARE SCHEMA ANCHOR SYSCAT.SCHEMATA.SCHEMANAME;
  DECLARE STATEMENT VARCHAR(256);
  DECLARE INEXISTANT_TABLE CONDITION FOR SQLSTATE '42704';
  DECLARE STMT STATEMENT;
  DECLARE SCHEMATA CURSOR WITH HOLD FOR
    SELECT SUITE_NAME
    FROM DB2UNIT_1.SUITES S;
  DECLARE CONTINUE HANDLER FOR NOT FOUND
    SET AT_END = TRUE;
  DECLARE CONTINUE HANDLER FOR INEXISTANT_TABLE BEGIN END;

  OPEN SCHEMATA;
  SET AT_END = FALSE;
  FETCH SCHEMATA INTO SCHEMA;
  WHILE (AT_END = FALSE) DO
   SET STATEMENT = 'DROP TABLE ' || TRIM(SCHEMA) || '.' || REPORTS_TABLE;
   PREPARE STMT FROM STATEMENT;
   EXECUTE STMT;
   FETCH SCHEMATA INTO SCHEMA;
  END WHILE;

  DELETE FROM DB2UNIT_1.SORTS;
  DELETE FROM DB2UNIT_1.SUITES_EXECUTIONS;
  DELETE FROM DB2UNIT_1.SUITE_LOCKS;
  DELETE FROM DB2UNIT_1.EXECUTION_REPORTS;
  DELETE FROM DB2UNIT_1.SUITES;
  DELETE FROM DB2UNIT_1.EXECUTIONS;
 END P_RESET_TABLES @

/**
 * Release the lock for a given suite. It should be used when a test suite
 * execution is cancelled and it does not finish correctly.
 *
 * IN NAME
 *   Name of the test suite for remove its lock.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE RELEASE_LOCK (
  NAME ANCHOR SYSCAT.SCHEMATA.SCHEMANAME
  )
  LANGUAGE SQL
  SPECIFIC P_RELEASE_LOCK
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_RELEASE_LOCK: BEGIN
  DECLARE STATEMENT VARCHAR(256);
  DECLARE CUR_SCHEMA ANCHOR SYSCAT.SCHEMATA.SCHEMANAME;
  DECLARE LOGGER_ID SMALLINT;
  DECLARE STMT STATEMENT;
  DECLARE EXIT HANDLER FOR NOT FOUND SET STATEMENT = '';

  CALL LOGGER.GET_LOGGER('DB2UNIT_1.DB2UNIT.RELEASE_LOCK',
    LOGGER_ID);

  CALL LOGGER.INFO(LOGGER_ID, 'Releasing lock for schema '
    || COALESCE(NAME, 'NULL'));

  SET NAME = PROCESS_SCHEMA(NAME);
  SET CUR_SCHEMA = (SELECT SCHEMANAME
    FROM SYSCAT.SCHEMATA
    WHERE SCHEMANAME = NAME);
  IF (CUR_SCHEMA IS NULL) THEN
   SET CUR_SCHEMA = (SELECT SCHEMANAME
     FROM SYSCAT.SCHEMATA
     WHERE SCHEMANAME = UPPER(NAME));
   IF (CUR_SCHEMA IS NOT NULL) THEN
    CALL LOGGER.INFO(LOGGER_ID, 'Lock released for schema '
      || COALESCE(CUR_SCHEMA, 'NULL') || ' if existed');
    SET STATEMENT = 'DELETE FROM ' || UTILITY_SCHEMA || '.SUITE_LOCKS '
      || 'WHERE NAME = ''' || CUR_SCHEMA || '''';
    PREPARE STMT FROM STATEMENT;
    EXECUTE STMT;
   ELSE
    CALL LOGGER.WARN(LOGGER_ID, 'Schema does not exist '
      || COALESCE(NAME, 'NULL'));
   END IF;
  ELSE
   CALL LOGGER.INFO(LOGGER_ID, 'Lock released for schema '
     || COALESCE(CUR_SCHEMA, 'NULL') || ' if existed');
   SET STATEMENT = 'DELETE FROM ' || UTILITY_SCHEMA || '.SUITE_LOCKS '
     || 'WHERE NAME = ''' || CUR_SCHEMA || '''';
   PREPARE STMT FROM STATEMENT;
   EXECUTE STMT;
  END IF;
 END P_RELEASE_LOCK @

/**
 * Release all locks associated to any tests suite.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE RELEASE_LOCKS (
  )
  LANGUAGE SQL
  SPECIFIC P_RELEASE_LOCKS
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_RELEASE_LOCKS: BEGIN
  DECLARE STATEMENT VARCHAR(256);
  DECLARE STMT STATEMENT;
  SET STATEMENT = 'DELETE FROM ' || UTILITY_SCHEMA || '.SUITE_LOCKS';
  PREPARE STMT FROM STATEMENT;
  EXECUTE STMT;
 END P_RELEASE_LOCKS @

/**
 * Changes the transaction autonomous mode.
 *
 * IN AUTONOMOUS
 *   True if the procedure should be executed autonomously. False otherwise.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE SET_AUTONOMOUS (
  IN AUTONOMOUS BOOLEAN
  )
  LANGUAGE SQL
  SPECIFIC P_SET_AUTONOMOUS
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_SET_AUTONOMOUS: BEGIN
  SET AUTONOMOUS_EXEC = AUTONOMOUS;
 END P_SET_AUTONOMOUS @

/**
 * Changes the sort type for the procedures.
 *
 * IN RANDOM
 *   True if the sort should be random, false if the sort is alphabetical.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE RANDOM_SORT (
  IN RANDOM BOOLEAN
  )
  LANGUAGE SQL
  SPECIFIC P_RANDOM_SORT
  DYNAMIC RESULT SETS 0
  READS SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_RANDOM_SORT: BEGIN
  SET RANDOM_SORT = RANDOM;
 END P_RANDOM_SORT @

/**
 * Exports the list of registered tests into a file that can be executed
 * directly from Linux.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE EXPORT_TESTS_LIST (
  )
  LANGUAGE SQL
  SPECIFIC P_EXPORT_TESTS_LIST
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_EXPORT_TESTS_LIST: BEGIN
  DECLARE VERSION VARCHAR(256);

  SET VERSION = (SELECT OS_NAME from SYSIBMADM.ENV_SYS_INFO);
  IF (SUBSTR(VERSION, 1, 3) = 'WIN') THEN
   CALL SYSPROC.ADMIN_CMD('EXPORT TO %TMP%\listOfTestSuites OF DEL MODIFIED BY NOCHARDEL '
     || 'SELECT * FROM (SELECT ''db2 -r %TMP%\db2unit.output -v '
     || 'CALL DB2UNIT.RUN_SUITE('''''' || SUITE_NAME || '''''')'' '
     || 'FROM DB2UNIT_1.SUITES) ORDER BY RAND()');
  ELSE
   CALL SYSPROC.ADMIN_CMD('EXPORT TO /tmp/listOfTestSuites OF DEL MODIFIED BY NOCHARDEL '
     || 'SELECT * FROM (SELECT ''db2 -r /tmp/db2unit.output -v '
     || '"CALL DB2UNIT.RUN_SUITE('''''' || SUITE_NAME || '''''')" ; '
     || 'touch /tmp/sum ; '
     || 'SUM=$(cat /tmp/sum) ; '
     || 'tail -1 /tmp/db2unit.output | awk ''''/Return Status/ {print "echo $(($SUM+"$4")) > /tmp/sum"}'''' | source /dev/stdin ; '
     || 'cat /tmp/sum '' '
     || 'FROM DB2UNIT_1.SUITES) ORDER BY RAND()');
   CALL SYSPROC.ADMIN_CMD('EXPORT TO /tmp/returnCode OF DEL MODIFIED BY NOCHARDEL '
     || 'SELECT ''exit $(cat /tmp/sum)'' FROM SYSIBM.SYSDUMMY1');
  END IF;
 END P_EXPORT_TESTS_LIST@

/**
 * Shows the license of this framework.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE LICENSE (
  )
  LANGUAGE SQL
  SPECIFIC P_LICENSE
  DYNAMIC RESULT SETS 1
  READS SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_LICENSE: BEGIN
  DECLARE LICENSE_CURSOR CURSOR
    WITH RETURN FOR
    SELECT LINE
    FROM LICENSE
    ORDER BY NUMBER;
  OPEN LICENSE_CURSOR;
 END P_LICENSE @

