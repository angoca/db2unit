--#SET TERMINATOR @

/*
 This file is part of db2unit: A unit testing framework for Db2 LUW.
 Copyright (C)  2014  Andres Gomez Casanova (@AngocA)

 db2unit is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 db2unit is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

 Andres Gomez Casanova <angocaATyahooDOTcom>
*/

SET CURRENT SCHEMA DB2UNIT_2_BETA @

/**
 * Asserts implementation.
 * Return codes:
 * 0 - OK.
 * 1 - Null-ability difference.
 * 2 - Different values.
 * 3 - Different length.
 * 4 - Invalid value.
 * 5 - Opposite null-ability.
 * 6 - Fail.
 * 7 - Not empty table.
 * 8 - Empty table.
 * 9 - Object does not exist.
 * 10 - Different quantity of columns.
 * 11 - Some of the entry values are null.
 * 12 - The content of the tables is different.
 *
 * dib dob: XML assertions.
 *
 * Version: 2014-05-02 V2_BETA
 * Author: Andres Gomez Casanova (AngocA)
 * Author: Robert Mala (dib dob)
 */

/**
 * Return code: 0 - OK.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE RET_OK INT CONSTANT 0 @

/**
 * Return code: 1 - Null-ability difference.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE RET_NULL_DIFF INT CONSTANT 1 @

/**
 * Return code: 2 - Different values.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE RET_DIFF_VALUE INT CONSTANT 2 @

/**
 * Return code: 3 - Different length.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE RET_DIFF_LENGTH INT CONSTANT 3 @

/**
 * Return code: 4 - Invalid value.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE RET_INVALID_VALUE INT CONSTANT 4 @

/**
 * Return code: 5 - Opposite null-ability.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE RET_OPPOSITE_NULL INT CONSTANT 5 @

/**
 * Return code: 6 - Fail.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE RET_FAIL INT CONSTANT 6 @

/**
 * Return code: 7 - Not empty table.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE RET_NOT_EMPTY_TABLE INT CONSTANT 7 @

/**
 * Return code: 8 - Empty table.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE RET_EMPTY_TABLE INT CONSTANT 8 @

/**
 * Return code: 9 - Object does not exist.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE RET_OBJECT_NON_EXIST INT CONSTANT 9 @

/**
 * Return code: 10 - Different quantity of columns.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE RET_DIFF_QTY_COLS INT CONSTANT 10 @

/**
 * Return code: 11 - Some of the entry values are null.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE RET_NULL_ENTRY INT CONSTANT 11 @

/**
 * Return code: 12 - The content of the tables is different.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE RET_DIFF_TABLES_CONTENT INT CONSTANT 12 @

/**
 * Max size for assertion messages.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE MESSAGE_OVERHEAD SMALLINT CONSTANT 50 @

/**
 * Size of the chunk of a truncated string.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE MESSAGE_CHUNK SMALLINT CONSTANT 100 @

/**
 * Max length for message in report.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE MAX_LENGTH_MESSAGE_REPORT INT CONSTANT 512 @

/**
 * Prepares the environment to run an assertion.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE BEGIN_ASSERTION(
  )
  LANGUAGE SQL
  SPECIFIC P_BEGIN_ASSERTION
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_BEGIN_ASSERTION: BEGIN
  IF (CUR_SCHEMA IS NULL OR REPORTS_TABLE IS NULL) THEN
   DELETE FROM TEMP_REPORT_TESTS;
  END IF;
 END P_BEGIN_ASSERTION @

/**
 * Returns an opened cursor if not into a test suite.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE END_ASSERTION(
  )
  LANGUAGE SQL
  SPECIFIC P_END_ASSERTION
  DYNAMIC RESULT SETS 1
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_END_ASSERTION: BEGIN
  DECLARE MSG_CURSOR CURSOR
    WITH RETURN TO CLIENT FOR
    SELECT SUBSTR(MESSAGE, 1, 120) MESSAGE FROM TEMP_REPORT_TESTS;
  IF (CUR_SCHEMA IS NULL OR REPORTS_TABLE IS NULL) THEN
   OPEN MSG_CURSOR;
  END IF;
 END P_END_ASSERTION @

/**
 * Processes the given message.
 */
ALTER MODULE DB2UNIT ADD
  FUNCTION PROC_MESSAGE(
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT
  ) RETURNS ANCHOR MAX_VALUES.MESSAGE_ASSERT
  LANGUAGE SQL
  SPECIFIC F_PROC_MESSAGE
  DETERMINISTIC
  NO EXTERNAL ACTION
  MODIFIES SQL DATA
 F_PROC_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.PROC_MESSAGE',
    LOGGER_ID);

  CALL LOGGER.DEBUG(LOGGER_ID, 'Before: "' || COALESCE (MESSAGE, 'NULL')
    || '"');

  SET MESSAGE = TRIM(MESSAGE);
  IF (MESSAGE IS NULL) THEN
   SET MESSAGE = '';
  ELSEIF (MESSAGE = '') THEN
   -- TODO check this again
   -- Do nothing. <> and != do not work.
  ELSE
   SET MESSAGE = MESSAGE || '. ';
  END IF;

  CALL LOGGER.DEBUG(LOGGER_ID, 'After: "' || COALESCE (MESSAGE, 'NULL')
    || '"');

  RETURN MESSAGE;
 END F_PROC_MESSAGE @

/**
 * Returns a character representation of the given boolean.
 *
 * IN VALUE
 *   Value to convert.
 * RETURN
 *   The corresponding representation of the given boolean.
 */
ALTER MODULE DB2UNIT ADD
  FUNCTION BOOL_TO_CHAR(
  IN VALUE BOOLEAN
  ) RETURNS CHAR(5)
  LANGUAGE SQL
  SPECIFIC F_BOOL_TO_CHAR
  DETERMINISTIC
  NO EXTERNAL ACTION
 F_BOOL_TO_CHAR: BEGIN
  DECLARE RET CHAR(5) DEFAULT 'FALSE';

  IF (VALUE IS NULL) THEN
    SET RET = 'NULL';
  ELSEIF (VALUE = TRUE) THEN
   SET RET = 'TRUE';
  END IF;
  RETURN RET;
 END F_BOOL_TO_CHAR @

-- GENERAL

/**
 * Fails the current message giving a reason in the message.
 *
 * IN MESSAGE
 *   Related message to the fail.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE FAIL (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT
  )
  LANGUAGE SQL
  SPECIFIC P_FAIL_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_FAIL_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'FAIL';

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.FAIL_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);

  CALL WRITE_IN_REPORT (ASSERT_TYPE);
  CALL WRITE_IN_REPORT (MESSAGE || 'Test failed');
  SET TEST_RESULT = RESULT_FAILED;
  SET RET = RET_FAIL;

  CALL END_ASSERTION();
  RETURN RET;
 END P_FAIL_MESSAGE @

-- STRING

/**
 * Asserts if the given two strings are the same, in null-ability, in length
 * and in content.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN EXPECTED
 *   Expected boolean.
 * IN ACTUAL
 *   Actual boolean.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_STRING_EQUALS (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN EXPECTED ANCHOR MAX_STRING.STRING,
  IN ACTUAL ANCHOR MAX_STRING.STRING
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_STRING_EQUALS_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_STRING_EQUALS_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE SHOW BOOLEAN DEFAULT FALSE;
  DECLARE LENGTH SMALLINT;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'STRING_EQUALS';

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_STRING_EQUALS_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, '"' || SUBSTR(EXPECTED, 1, 500) || '"');
  CALL LOGGER.DEBUG(LOGGER_ID, '"' || SUBSTR(ACTUAL, 1, 500) || '"');

  -- Check values.
  IF ((EXPECTED IS NULL AND ACTUAL IS NOT NULL)
    OR (EXPECTED IS NOT NULL AND ACTUAL IS NULL)) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'Nullability difference');
   SET SHOW = TRUE;
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_NULL_DIFF;
  ELSEIF (LENGTH(EXPECTED) <> LENGTH(ACTUAL)) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'Strings have different lengths');
   SET SHOW = TRUE;
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_DIFF_LENGTH;
  ELSEIF (EXPECTED <> ACTUAL) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The content of both strings is different');
   SET SHOW = TRUE;
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_DIFF_VALUE;
  END IF;

  -- Show problems.
  IF (SHOW = TRUE) THEN
   IF (EXPECTED IS NOT NULL) THEN
    SET LENGTH = LENGTH(EXPECTED);
    IF (LENGTH < MAX_MESSAGE - MESSAGE_OVERHEAD) THEN
     CALL WRITE_IN_REPORT (SUBSTR('Expected      : "' || EXPECTED || '"', 1,
       MAX_LENGTH_MESSAGE_REPORT));
    ELSE
     SET EXPECTED = SUBSTR(EXPECTED, 1, MESSAGE_CHUNK) || '"..."'
       || SUBSTR(EXPECTED, LENGTH - MESSAGE_CHUNK);
     CALL WRITE_IN_REPORT (SUBSTR('Expd truncated: "' || EXPECTED || '"', 1,
       MAX_LENGTH_MESSAGE_REPORT));
    END IF;
   ELSE
    CALL WRITE_IN_REPORT ('Expected      : NULL');
   END IF;
   IF (ACTUAL IS NOT NULL) THEN
    SET LENGTH = LENGTH(ACTUAL);
    IF (LENGTH < MAX_MESSAGE - MESSAGE_OVERHEAD) THEN
     CALL WRITE_IN_REPORT (SUBSTR('Actual        : "' || ACTUAL || '"', 1,
       MAX_LENGTH_MESSAGE_REPORT));
    ELSE
     SET ACTUAL = SUBSTR(ACTUAL, 1, MESSAGE_CHUNK) || '"..."'
       || SUBSTR(ACTUAL, LENGTH - MESSAGE_CHUNK);
     CALL WRITE_IN_REPORT (SUBSTR('Actl truncated: "' || ACTUAL || '"', 1,
       MAX_LENGTH_MESSAGE_REPORT));
    END IF;
   ELSE
    CALL WRITE_IN_REPORT ('Actual        : NULL');
   END IF;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_STRING_EQUALS_MESSAGE @

/**
 * Asserts if the given string is null.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN STRING
 *   Value to check if it is null.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_STRING_NULL (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN STRING ANCHOR MAX_STRING.STRING
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_STRING_NULL_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_STRING_NULL_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'STRING_NULL';

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_STRING_NULL_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, '"' || SUBSTR(STRING, 1, 500) || '"');

  -- Check value.
  IF (STRING IS NOT NULL) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The given string is "NOT NULL"');
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_OPPOSITE_NULL;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_STRING_NULL_MESSAGE @

/**
 * Asserts if the given string is not null.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN STRING
 *   Value to check if it is not null.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_STRING_NOT_NULL (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN STRING ANCHOR MAX_STRING.STRING
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_STRING_NOT_NULL_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_STRING_NOT_NULL_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'STRING_NOT_NULL';

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_STRING_NOT_NULL_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, '"' || SUBSTR(STRING, 1, 500) || '"');

  -- Check value.
  IF (STRING IS NULL) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The given string is "NULL"');
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_OPPOSITE_NULL;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_STRING_NOT_NULL_MESSAGE @

-- BOOLEAN

/**
 * Asserts if the given two booleans are the same, in null-ability and in
 * content.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN EXPECTED
 *   Expected boolean.
 * IN ACTUAL
 *   Actual boolean.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_BOOLEAN_EQUALS (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN EXPECTED BOOLEAN,
  IN ACTUAL BOOLEAN
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_BOOLEAN_EQUALS_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_BOOLEAN_EQUALS_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE SHOW BOOLEAN DEFAULT FALSE;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'BOOLEAN_EQUALS';

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_BOOLEAN_EQUALS_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, BOOL_TO_CHAR(EXPECTED));
  CALL LOGGER.DEBUG(LOGGER_ID, BOOL_TO_CHAR(ACTUAL));

  -- Check values.
  IF ((EXPECTED IS NULL AND ACTUAL IS NOT NULL)
    OR (EXPECTED IS NOT NULL AND ACTUAL IS NULL)) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'Nullability difference');
   SET SHOW = TRUE;
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_NULL_DIFF;
  ELSEIF (EXPECTED <> ACTUAL) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The value of both booleans is different');
   SET SHOW = TRUE;
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_DIFF_VALUE;
  END IF;

  -- Show problems.
  IF (SHOW = TRUE) THEN
   IF (EXPECTED IS NOT NULL) THEN
    CALL WRITE_IN_REPORT ('Expected: "' || BOOL_TO_CHAR(EXPECTED) || '"');
   ELSE
    CALL WRITE_IN_REPORT ('Expected: NULL');
   END IF;
   IF (ACTUAL IS NOT NULL) THEN
    CALL WRITE_IN_REPORT ('Actual  : "' || BOOL_TO_CHAR(ACTUAL) || '"');
   ELSE
    CALL WRITE_IN_REPORT ('Actual  : NULL');
   END IF;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_BOOLEAN_EQUALS_MESSAGE @

/**
 * Asserts if the given value is true.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN CONDITION
 *   Value to check against TRUE.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_BOOLEAN_TRUE (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN CONDITION BOOLEAN
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_BOOLEAN_TRUE_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_BOOLEAN_TRUE_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'BOOLEAN_TRUE';

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_BOOLEAN_TRUE_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, BOOL_TO_CHAR(CONDITION));

  -- Check value.
  IF (CONDITION = FALSE) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The given value is "FALSE"');
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_INVALID_VALUE;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_BOOLEAN_TRUE_MESSAGE @

/**
 * Asserts if the given value is false.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN CONDITION
 *   Value to check against FALSE.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_BOOLEAN_FALSE (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN CONDITION BOOLEAN
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_BOOLEAN_FALSE_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_BOOLEAN_FALSE_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'BOOLEAN_FALSE';

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_BOOLEAN_FALSE_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, BOOL_TO_CHAR(CONDITION));

  -- Check value.
  IF (CONDITION = TRUE) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The given value is "TRUE"');
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_INVALID_VALUE;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_BOOLEAN_FALSE_MESSAGE @

/**
 * Asserts if the given boolean is null.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN CONDITION
 *   Value to check if it is null.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_BOOLEAN_NULL (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN CONDITION BOOLEAN
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_BOOLEAN_NULL_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_BOOLEAN_NULL_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'BOOLEAN_NULL';

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_BOOLEAN_NULL_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, BOOL_TO_CHAR(CONDITION));

  -- Check value.
  IF (CONDITION IS NOT NULL) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The given value is "NOT NULL"');
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_OPPOSITE_NULL;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_BOOLEAN_NULL_MESSAGE @

/**
 * Asserts if the given boolean is not null.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN CONDITION
 *   Value to check if it is not null.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_BOOLEAN_NOT_NULL (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN CONDITION BOOLEAN
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_BOOLEAN_NOT_NULL_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_BOOLEAN_NOT_NULL_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'BOOLEAN_NOT_NULL';

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_BOOLEAN_NOT_NULL_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, BOOL_TO_CHAR(CONDITION));

  -- Check value.
  IF (CONDITION IS NULL) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The given value is "NULL"');
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_OPPOSITE_NULL;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_BOOLEAN_NOT_NULL_MESSAGE @

-- INTEGER

/**
 * Asserts if the given two int are the same, in null-ability and in content.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN EXPECTED
 *   Expected int.
 * IN ACTUAL
 *   Actual int.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_INT_EQUALS (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN EXPECTED BIGINT,
  IN ACTUAL BIGINT
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_INT_EQUALS_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_INT_EQUALS_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE SHOW BOOLEAN DEFAULT FALSE;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'INT_EQUALS';

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_INT_EQUALS_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, EXPECTED);
  CALL LOGGER.DEBUG(LOGGER_ID, ACTUAL);

  -- Check values.
  IF ((EXPECTED IS NULL AND ACTUAL IS NOT NULL)
    OR (EXPECTED IS NOT NULL AND ACTUAL IS NULL)) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'Nullability difference');
   SET SHOW = TRUE;
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_NULL_DIFF;
  ELSEIF (EXPECTED <> ACTUAL) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The value of both integers is different');
   SET SHOW = TRUE;
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_DIFF_VALUE;
  END IF;

  -- Show problems.
  IF (SHOW = TRUE) THEN
   IF (EXPECTED IS NOT NULL) THEN
    CALL WRITE_IN_REPORT ('Expected: "' || EXPECTED || '"');
   ELSE
    CALL WRITE_IN_REPORT ('Expected: NULL');
   END IF;
   IF (ACTUAL IS NOT NULL) THEN
    CALL WRITE_IN_REPORT ('Actual  : "' || ACTUAL || '"');
   ELSE
    CALL WRITE_IN_REPORT ('Actual  : NULL');
   END IF;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_INT_EQUALS_MESSAGE @

/**
 * Asserts if the given value is null.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN VALUE
 *   Value to check if it is null.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_INT_NULL (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN VALUE BIGINT
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_INT_NULL_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_INT_NULL_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'INT_NULL';

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_INT_NULL_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, VALUE);

  -- Check value.
  IF (VALUE IS NOT NULL) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The given value is "NOT NULL"');
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_OPPOSITE_NULL;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_INT_NULL_MESSAGE @

/**
 * Asserts if the given integer is not null.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN VALUE
 *   Value to check if it is not null.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_INT_NOT_NULL (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN VALUE BIGINT
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_INT_NOT_NULL_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_INT_NOT_NULL_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'INT_NOT_NULL';

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_INT_NOT_NULL_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, VALUE);

  -- Check value.
  IF (VALUE IS NULL) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The given value is "NULL"');
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_OPPOSITE_NULL;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_INT_NOT_NULL_MESSAGE @

-- DECIMAL

/**
 * Asserts if the given two decimals are the same, in null-ability and in
 * content.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN EXPECTED
 *   Expected decimal.
 * IN ACTUAL
 *   Actual decimal.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_DEC_EQUALS (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN EXPECTED DECFLOAT,
  IN ACTUAL DECFLOAT
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_DEC_EQUALS_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_DEC_EQUALS_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE SHOW BOOLEAN DEFAULT FALSE;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'DEC_EQUALS';

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_DEC_EQUALS_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, EXPECTED);
  CALL LOGGER.DEBUG(LOGGER_ID, ACTUAL);

  -- Check values.
  IF ((EXPECTED IS NULL AND ACTUAL IS NOT NULL)
    OR (EXPECTED IS NOT NULL AND ACTUAL IS NULL)) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'Nullability difference');
   SET SHOW = TRUE;
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_NULL_DIFF;
  ELSEIF (EXPECTED <> ACTUAL) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The value of both decimals is different');
   SET SHOW = TRUE;
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_DIFF_VALUE;
  END IF;

  -- Show problems.
  IF (SHOW = TRUE) THEN
   IF (EXPECTED IS NOT NULL) THEN
    CALL WRITE_IN_REPORT ('Expected: "' || EXPECTED || '"');
   ELSE
    CALL WRITE_IN_REPORT ('Expected: NULL');
   END IF;
   IF (ACTUAL IS NOT NULL) THEN
    CALL WRITE_IN_REPORT ('Actual  : "' || ACTUAL || '"');
   ELSE
    CALL WRITE_IN_REPORT ('Actual  : NULL');
   END IF;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_DEC_EQUALS_MESSAGE @

/**
 * Asserts if the given value is null.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN VALUE
 *   Value to check if it is null.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_DEC_NULL (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN VALUE DECFLOAT
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_DEC_NULL_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_DEC_NULL_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'DEC_NULL';

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_DEC_NULL_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, VALUE);

  -- Check value.
  IF (VALUE IS NOT NULL) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The given value is "NOT NULL"');
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_OPPOSITE_NULL;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_DEC_NULL_MESSAGE @

/**
 * Asserts if the given decimal is not null.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN VALUE
 *   Value to check if it is not null.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_DEC_NOT_NULL (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN VALUE DECFLOAT
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_DEC_NOT_NULL_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_DEC_NOT_NULL_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'DEC_NOT_NULL';

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_DEC_NOT_NULL_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, VALUE);

  -- Check value.
  IF (VALUE IS NULL) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The given value is "NULL"');
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_OPPOSITE_NULL;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_DEC_NOT_NULL_MESSAGE @

-- TABLES

/**
 * Checks the content difference between two tables.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN EXPECTED_SCHEMA
 *   Schema of the table as model.
 * IN EXPECTED_TABLE_NAME
 *   Name of the table to analyse.
 * IN ACTUAL_SCHEMA
 *   Schema of the resulting table.
 * IN ACTUAL_TABLE_NAME
 *   Name of the resulting table.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE CHECK_TABLE_CONTENT (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN EXPECTED_SCHEMA ANCHOR SYSCAT.TABLES.TABSCHEMA,
  IN EXPECTED_TABLE_NAME ANCHOR SYSCAT.TABLES.TABNAME,
  IN ACTUAL_SCHEMA ANCHOR SYSCAT.TABLES.TABSCHEMA,
  IN ACTUAL_TABLE_NAME ANCHOR SYSCAT.TABLES.TABNAME
  )
  LANGUAGE SQL
  SPECIFIC P_CHECK_TABLE_CONTENT
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_CHECK_TABLE_CONTENT: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE RET INTEGER;
  DECLARE SENTENCE ANCHOR MAX_VALUES.SENTENCE;
  DECLARE QTY INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'TABLE_EQUALS';
  DECLARE STMT STATEMENT;

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.CHECK_TABLE_CONTENT', LOGGER_ID);

  SET RET = RET_OK;

  SET SENTENCE = 'SET ? = (SELECT COUNT(1) FROM (SELECT * FROM '
    || EXPECTED_SCHEMA || '.' || EXPECTED_TABLE_NAME
    || ' MINUS SELECT * FROM '
    || ACTUAL_SCHEMA || '.' || ACTUAL_TABLE_NAME
    || ') A)';
  CALL LOGGER.DEBUG(LOGGER_ID, SENTENCE);
  PREPARE STMT FROM SENTENCE;
  EXECUTE STMT INTO QTY;

 IF (QTY = 0) THEN
  -- OK
 ELSE
  CALL WRITE_IN_REPORT (ASSERT_TYPE);
  CALL WRITE_IN_REPORT (MESSAGE || 'Tables have different content');
  SET RET = RET_DIFF_TABLES_CONTENT;
 END IF;

  SET SENTENCE = 'SET ? = (SELECT COUNT(1) FROM (SELECT * FROM '
    || ACTUAL_SCHEMA || '.' || ACTUAL_TABLE_NAME
    || ' MINUS SELECT * FROM '
    || EXPECTED_SCHEMA || '.' || EXPECTED_TABLE_NAME
    || ') A)';
  CALL LOGGER.DEBUG(LOGGER_ID, SENTENCE);
  PREPARE STMT FROM SENTENCE;
  EXECUTE STMT INTO QTY;

 IF (QTY = 0) THEN
  -- OK
 ELSE
  CALL WRITE_IN_REPORT (ASSERT_TYPE);
  CALL WRITE_IN_REPORT (MESSAGE || 'Tables have different content');
  SET RET = RET_DIFF_TABLES_CONTENT;
 END IF;

  RETURN RET;
 END P_CHECK_TABLE_CONTENT @

/**
 * Asserts if the given two tables are equal in structure and content.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN EXPECTED_SCHEMA
 *   Schema of the table as model.
 * IN EXPECTED_TABLE_NAME
 *   Name of the table to analyse.
 * IN ACTUAL_SCHEMA
 *   Schema of the resulting table.
 * IN ACTUAL_TABLE_NAME
 *   Name of the resulting table.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_TABLE_EQUALS (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN EXPECTED_SCHEMA ANCHOR SYSCAT.TABLES.TABSCHEMA,
  IN EXPECTED_TABLE_NAME ANCHOR SYSCAT.TABLES.TABNAME,
  IN ACTUAL_SCHEMA ANCHOR SYSCAT.TABLES.TABSCHEMA,
  IN ACTUAL_TABLE_NAME ANCHOR SYSCAT.TABLES.TABNAME
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_TABLE_EQUALS_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_TABLE_EQUALS_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE RET INT;
  DECLARE EXP_QTY SMALLINT;
  DECLARE ACT_QTY SMALLINT;
  DECLARE INDEX SMALLINT;
  DECLARE COLNAME ANCHOR SYSCAT.COLUMNS.COLNAME;
  DECLARE SENTENCE ANCHOR MAX_VALUES.SENTENCE;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'TABLE_EQUALS';
  DECLARE STMT STATEMENT;

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_TABLE_EQUALS',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, EXPECTED_SCHEMA);
  CALL LOGGER.DEBUG(LOGGER_ID, EXPECTED_TABLE_NAME);
  CALL LOGGER.DEBUG(LOGGER_ID, ACTUAL_SCHEMA);
  CALL LOGGER.DEBUG(LOGGER_ID, ACTUAL_TABLE_NAME);
  IF (EXPECTED_SCHEMA IS NULL OR EXPECTED_TABLE_NAME IS NULL
    OR ACTUAL_SCHEMA IS NULL OR ACTUAL_TABLE_NAME IS NULL) THEN
    CALL WRITE_IN_REPORT (ASSERT_TYPE);
    CALL WRITE_IN_REPORT (SUBSTR(MESSAGE || 'Some of the entry values are '
      || 'null: ' || COALESCE(EXPECTED_SCHEMA, 'NULL') || ','
      || COALESCE(EXPECTED_TABLE_NAME, 'NULL') || ','
      || COALESCE(ACTUAL_SCHEMA, 'NULL') || ','
      || COALESCE(ACTUAL_TABLE_NAME, 'NULL'), 1, 512));
    SET RET = 14;
  END IF;

  -- Checks quantity of columns.
  IF (RET = RET_OK) THEN
   SET SENTENCE = 'SET ? = (SELECT COLCOUNT '
     || 'FROM SYSCAT.TABLES '
     || 'WHERE TABSCHEMA = ''' || EXPECTED_SCHEMA || ''' '
     || 'AND TABNAME = ''' || EXPECTED_TABLE_NAME || ''')';
   CALL LOGGER.DEBUG(LOGGER_ID, SENTENCE);
   PREPARE STMT FROM SENTENCE;
   EXECUTE STMT INTO EXP_QTY;
   SET SENTENCE = 'SET ? = (SELECT COLCOUNT '
     || 'FROM SYSCAT.TABLES '
     || 'WHERE TABSCHEMA = ''' || ACTUAL_SCHEMA || ''' '
     || 'AND TABNAME = ''' || ACTUAL_TABLE_NAME || ''')';
   CALL LOGGER.DEBUG(LOGGER_ID, SENTENCE);
   PREPARE STMT FROM SENTENCE;
   EXECUTE STMT INTO ACT_QTY;
   IF (EXP_QTY <> ACT_QTY) THEN
    CALL WRITE_IN_REPORT (ASSERT_TYPE);
    CALL WRITE_IN_REPORT (MESSAGE || 'Different quantity of columns');
    SET RET = RET_DIFF_QTY_COLS;
   END IF;
  END IF;

  -- Checks the content of the table.
  IF (RET = RET_OK) THEN
   CALL CHECK_TABLE_CONTENT(MESSAGE, EXPECTED_SCHEMA, EXPECTED_TABLE_NAME,
      ACTUAL_SCHEMA, ACTUAL_TABLE_NAME);
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_TABLE_EQUALS_MESSAGE @

/**
 * Checks if the table is empty. Returns TRUE if the table is empty, false
 * otherwise.
 *
 * IN SCHEMA
 *   Schema of the table.
 * IN TABLE_NAME
 *   Name of the table to analyse.
 */
ALTER MODULE DB2UNIT ADD
  FUNCTION CHECK_TABLE_EMPTYNESS (
  IN SCHEMA ANCHOR SYSCAT.TABLES.TABSCHEMA,
  IN TABLE_NAME ANCHOR SYSCAT.TABLES.TABNAME
  ) RETURNS BOOLEAN
  LANGUAGE SQL
  SPECIFIC F_CHECK_TABLE_EMPTYNESS
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 F_CHECK_TABLE_EMPTYNESS: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE RET BOOLEAN;
  DECLARE CNT INT;
  DECLARE SENTENCE ANCHOR MAX_VALUES.SENTENCE;
  DECLARE WHOLE_NAME ANCHOR SYSCAT.TABLES.TABNAME;
  DECLARE STMT STATEMENT;

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.CHECK_TABLE_EMPTYNESS',
    LOGGER_ID);

  IF (SCHEMA IS NOT NULL) THEN
    SET WHOLE_NAME = TRIM(SCHEMA) || '.' || TRIM(TABLE_NAME);
  ELSE
    SET WHOLE_NAME = TRIM(TABLE_NAME);
  END IF;

  SET SENTENCE = 'SET ? = (SELECT COUNT(0) '
    || 'FROM ' || WHOLE_NAME || ')';
  CALL LOGGER.DEBUG(LOGGER_ID, SENTENCE);
  PREPARE STMT FROM SENTENCE;
  EXECUTE STMT INTO CNT;

  IF (CNT > 0) THEN
   SET RET = FALSE;
  ELSEIF (CNT = 0) THEN
   SET RET = TRUE;
  ELSE
   SET RET = NULL;
  END IF;

  RETURN RET;
 END F_CHECK_TABLE_EMPTYNESS @

/**
 * Asserts that the given name corresponds to an empty table with a related
 * test message.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN SCHEMA
 *   Schema of the table.
 * IN TABLE_NAME
 *   Name of the table to analyse.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_TABLE_EMPTY (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN SCHEMA ANCHOR SYSCAT.TABLES.TABSCHEMA,
  IN TABLE_NAME ANCHOR SYSCAT.TABLES.TABNAME
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_TABLE_EMPTY_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_TABLE_EMPTY_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE EMPTY BOOLEAN;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'TABLE_EMPTY';
  DECLARE INEXISTANT_TABLE CONDITION FOR SQLSTATE '42704';
  DECLARE EXIT HANDLER FOR INEXISTANT_TABLE
    BEGIN
     CALL WRITE_IN_REPORT (ASSERT_TYPE);
     CALL WRITE_IN_REPORT('Table does not exist ' || COALESCE(SCHEMA, 'NULL')
       || '.' || COALESCE(TABLE_NAME, 'NULL'));
     SET RET = RET_OBJECT_NON_EXIST;

     CALL END_ASSERTION();
     RETURN RET;
    END;

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_TABLE_EMPTY',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, TABLE_NAME);

  -- Check value.
  SET EMPTY = CHECK_TABLE_EMPTYNESS(SCHEMA, TABLE_NAME);
  IF (EMPTY = FALSE) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The table is not empty');
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_NOT_EMPTY_TABLE;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_TABLE_EMPTY_MESSAGE @

/**
 * Asserts that the given name corresponds to a non empty table with a related
 * test message.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN SCHEMA
 *   Schema of the table.
 * IN TABLE_NAME
 *   Name of the table to analyse.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_TABLE_NON_EMPTY (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN SCHEMA ANCHOR SYSCAT.TABLES.TABSCHEMA,
  IN TABLE_NAME ANCHOR SYSCAT.TABLES.TABNAME
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_TABLE_NON_EMPTY_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_TABLE_NON_EMPTY_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE EMPTY BOOLEAN;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'TABLE_NON_EMPTY';
  DECLARE INEXISTANT_TABLE CONDITION FOR SQLSTATE '42704';
  DECLARE EXIT HANDLER FOR INEXISTANT_TABLE
    BEGIN
     CALL WRITE_IN_REPORT (ASSERT_TYPE);
     CALL WRITE_IN_REPORT('Table does not exist ' || COALESCE(SCHEMA, 'NULL')
       || '.' || COALESCE(TABLE_NAME, 'NULL'));
     SET RET = RET_OBJECT_NON_EXIST;

     CALL END_ASSERTION();
     RETURN RET;
    END;

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_TABLE_NON_EMPTY',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, TABLE_NAME);

  -- Check value.
  SET EMPTY = CHECK_TABLE_EMPTYNESS(SCHEMA, TABLE_NAME);
  IF (EMPTY = TRUE) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The table is empty');
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_EMPTY_TABLE;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_TABLE_NON_EMPTY_MESSAGE@

-- DATETIMES (TIMESTAMP)

/**
 * Asserts if the given two timestamps are the same, in null-ability and in
 * content.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN EXPECTED
 *   Expected timestamp.
 * IN ACTUAL
 *   Actual timestamp.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_TIMESTAMP_EQUALS (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN EXPECTED TIMESTAMP,
  IN ACTUAL TIMESTAMP
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_TIMESTAMP_EQUALS_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_TIMESTAMP_EQUALS_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE SHOW BOOLEAN DEFAULT FALSE;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'TIMESTAMP_EQUALS';

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_TIMESTAMP_EQUALS_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, EXPECTED);
  CALL LOGGER.DEBUG(LOGGER_ID, ACTUAL);

  -- Check values.
  IF ((EXPECTED IS NULL AND ACTUAL IS NOT NULL)
    OR (EXPECTED IS NOT NULL AND ACTUAL IS NULL)) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'Nullability difference');
   SET SHOW = TRUE;
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_NULL_DIFF;
  ELSEIF (EXPECTED <> ACTUAL) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The value of both timestamps is '
     || 'different');
   SET SHOW = TRUE;
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_DIFF_VALUE;
  END IF;

  -- Show problems.
  IF (SHOW = TRUE) THEN
   IF (EXPECTED IS NOT NULL) THEN
    CALL WRITE_IN_REPORT ('Expected: "' || EXPECTED || '"');
   ELSE
    CALL WRITE_IN_REPORT ('Expected: NULL');
   END IF;
   IF (ACTUAL IS NOT NULL) THEN
    CALL WRITE_IN_REPORT ('Actual  : "' || ACTUAL || '"');
   ELSE
    CALL WRITE_IN_REPORT ('Actual  : NULL');
   END IF;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_TIMESTAMP_EQUALS_MESSAGE @

/**
 * Asserts if the given timestamp is null.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN VALUE
 *   Value to check if it is null.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_TIMESTAMP_NULL (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN VALUE TIMESTAMP
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_TIMESTAMP_NULL_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_TIMESTAMP_NULL_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'TIMESTAMP_NULL';

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_TIMESTAMP_NULL_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, VALUE);

  -- Check value.
  IF (VALUE IS NOT NULL) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The given value is "NOT NULL"');
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_OPPOSITE_NULL;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_TIMESTAMP_NULL_MESSAGE @

/**
 * Asserts if the given timestamp is not null.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN VALUE
 *   Value to check if it is not null.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_TIMESTAMP_NOT_NULL (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN VALUE TIMESTAMP
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_TIMESTAMP_NOT_NULL_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_TIMESTAMP_NOT_NULL_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(32) CONSTANT 'TIMESTAMP_NOT_NULL';

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_TIMESTAMP_NOT_NULL_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, VALUE);

  -- Check value.
  IF (VALUE IS NULL) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The given value is "NULL"');
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_OPPOSITE_NULL;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_TIMESTAMP_NOT_NULL_MESSAGE @

-- DATETIMES (DATE)

/**
 * Asserts if the given two dates are the same, in null-ability and in content.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN EXPECTED
 *   Expected date.
 * IN ACTUAL
 *   Actual date.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_DATE_EQUALS (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN EXPECTED DATE,
  IN ACTUAL DATE
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_DATE_EQUALS_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_DATE_EQUALS_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE SHOW BOOLEAN DEFAULT FALSE;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'DATE_EQUALS';
  DECLARE DATE_FORMATTED VARCHAR(16);

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_DATE_EQUALS_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, EXPECTED);
  CALL LOGGER.DEBUG(LOGGER_ID, ACTUAL);

  -- Check values.
  IF ((EXPECTED IS NULL AND ACTUAL IS NOT NULL)
    OR (EXPECTED IS NOT NULL AND ACTUAL IS NULL)) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'Nullability difference');
   SET SHOW = TRUE;
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_NULL_DIFF;
  ELSEIF (EXPECTED <> ACTUAL) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The value of both dates is '
     || 'different');
   SET SHOW = TRUE;
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_DIFF_VALUE;
  END IF;

  -- Show problems.
  IF (SHOW = TRUE) THEN
   IF (EXPECTED IS NOT NULL) THEN
    SET DATE_FORMATTED = VARCHAR_FORMAT(EXPECTED, 'YYYY-MM-DD');
    CALL WRITE_IN_REPORT ('Expected: "' || DATE_FORMATTED || '"');
   ELSE
    CALL WRITE_IN_REPORT ('Expected: NULL');
   END IF;
   IF (ACTUAL IS NOT NULL) THEN
    SET DATE_FORMATTED = VARCHAR_FORMAT(ACTUAL, 'YYYY-MM-DD');
    CALL WRITE_IN_REPORT ('Actual  : "' || DATE_FORMATTED || '"');
   ELSE
    CALL WRITE_IN_REPORT ('Actual  : NULL');
   END IF;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_DATE_EQUALS_MESSAGE @

/**
 * Asserts if the given date is null.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN VALUE
 *   Value to check if it is null.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_DATE_NULL (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN VALUE DATE
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_DATE_NULL_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_DATE_NULL_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'DATE_NULL';

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_DATE_NULL_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, VALUE);

  -- Check value.
  IF (VALUE IS NOT NULL) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The given value is "NOT NULL"');
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_OPPOSITE_NULL;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_DATE_NULL_MESSAGE @

/**
 * Asserts if the given date is not null.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN VALUE
 *   Value to check if it is not null.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_DATE_NOT_NULL (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN VALUE DATE
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_DATE_NOT_NULL_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_DATE_NOT_NULL_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'DATE_NOT_NULL';

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_DATE_NOT_NULL_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, VALUE);

  -- Check value.
  IF (VALUE IS NULL) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The given value is "NULL"');
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_OPPOSITE_NULL;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_DATE_NOT_NULL_MESSAGE @

-- DATETIMES (TIME)

/**
 * Asserts if the given two times are the same, in null-ability and in content.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN EXPECTED
 *   Expected time.
 * IN ACTUAL
 *   Actual time.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_TIME_EQUALS (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN EXPECTED TIME,
  IN ACTUAL TIME
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_TIME_EQUALS_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_TIME_EQUALS_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE SHOW BOOLEAN DEFAULT FALSE;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'TIME_EQUALS';

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_TIME_EQUALS_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, EXPECTED);
  CALL LOGGER.DEBUG(LOGGER_ID, ACTUAL);

  -- Check values.
  IF ((EXPECTED IS NULL AND ACTUAL IS NOT NULL)
    OR (EXPECTED IS NOT NULL AND ACTUAL IS NULL)) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'Nullability difference');
   SET SHOW = TRUE;
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_NULL_DIFF;
  ELSEIF (EXPECTED <> ACTUAL) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The value of both times is '
     || 'different');
   SET SHOW = TRUE;
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_DIFF_VALUE;
  END IF;

  -- Show problems.
  IF (SHOW = TRUE) THEN
   IF (EXPECTED IS NOT NULL) THEN
    CALL WRITE_IN_REPORT ('Expected: "' || EXPECTED || '"');
   ELSE
    CALL WRITE_IN_REPORT ('Expected: NULL');
   END IF;
   IF (ACTUAL IS NOT NULL) THEN
    CALL WRITE_IN_REPORT ('Actual  : "' || ACTUAL || '"');
   ELSE
    CALL WRITE_IN_REPORT ('Actual  : NULL');
   END IF;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_TIME_EQUALS_MESSAGE @

/**
 * Asserts if the given time is null.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN VALUE
 *   Value to check if it is null.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_TIME_NULL (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN VALUE TIME
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_TIME_NULL_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_TIME_NULL_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'TIME_NULL';

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_TIME_NULL_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, VALUE);

  -- Check value.
  IF (VALUE IS NOT NULL) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The given value is "NOT NULL"');
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_OPPOSITE_NULL;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_TIME_NULL_MESSAGE @

/**
 * Asserts if the given time is not null.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN VALUE
 *   Value to check if it is not null.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_TIME_NOT_NULL (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
  IN VALUE TIME
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_TIME_NOT_NULL_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
 P_ASSERT_TIME_NOT_NULL_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'TIME_NOT_NULL';

  CALL LOGGER.GET_LOGGER('DB2UNIT_2_BETA.DB2UNIT.ASSERT_TIME_NOT_NULL_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, VALUE);

  -- Check value.
  IF (VALUE IS NULL) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The given value is "NULL"');
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_OPPOSITE_NULL;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_TIME_NOT_NULL_MESSAGE @

-- XML

/**
 * Returns a value that indicates if the two XML sequence meet the requirements
 * of deep equality. For more information:
 * http://www-01.ibm.com/support/knowledgecenter/SSEPGG_10.5.0/com.ibm.db2.luw.xml.doc/doc/xqrfndpe.html
 *
 * IN SEQUENCE1
 *   First sequence to compare.
 * IN SEQUENCE2
 *   Second sequence to compare.
 * RETURN
 *   An integer that represents the boolean value of true or false.
 */
ALTER MODULE DB2UNIT ADD
  FUNCTION DEEP_EQUAL(
_IF __SQLSTATE_429BB _THEN
  IN SEQUENCE1 CLOB,
  IN SEQUENCE2 CLOB
_ELSE
  IN SEQUENCE1 XML,
  IN SEQUENCE2 XML
_END
  ) RETURNS INT
  LANGUAGE SQL
  SPECIFIC F_DEEP_EQUAL
  DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 F_DEEP_EQUAL: BEGIN
  RETURN
    XMLCAST(
     XMLQUERY(
      ' deep-equal( $S1, $S2 ) '
      PASSING
_IF __SQLSTATE_429BB _THEN
        XMLPARSE( DOCUMENT SEQUENCE1 ) AS "S1",
        XMLPARSE( DOCUMENT SEQUENCE2 ) AS "S2"
_ELSE
        SEQUENCE1 AS "S1",
        SEQUENCE2 AS "S2"
_END
     )
    AS INTEGER);
 END F_DEEP_EQUAL @

/**
 * Returns a sequence in the output value that represents the XML document.
 *
 * IN DOCUMENT
 *   XML document to process.
 * OUT SEQUENCE
 *   Sequence that represent the XML document.
 * IN QUERY
 *   A specific xPath in the XML document. This can be null and will be
 *   converted to $d.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE QUERY_XML (
_IF __SQLSTATE_429BB _THEN
  IN DOCUMENT CLOB,
  OUT SEQUENCE CLOB,
_ELSE
  IN DOCUMENT XML,
  OUT SEQUENCE XML,
_END
  IN QUERY CLOB DEFAULT ''
  )
  LANGUAGE SQL
  SPECIFIC P_QUERY_XML
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_QUERY_XML: BEGIN ATOMIC
  DECLARE C1 CURSOR FOR S1;
  PREPARE S1 FROM
_IF __SQLSTATE_429BB _THEN
    'SELECT XMLCAST( XMLSERIALIZE( XMLQUERY(''$D' || COALESCE(QUERY, '')
    || ''' PASSING XMLPARSE( DOCUMENT CAST( ? AS CLOB ) ) AS "D" ) ) AS CLOB)'
    || ' FROM SYSIBM.SYSDUMMY1';
_ELSE
    'SELECT XMLQUERY(''$D' || COALESCE(QUERY, '')
    || ''' PASSING CAST( ? AS XML ) AS "D" )'
    || ' FROM SYSIBM.SYSDUMMY1';
_END
  OPEN C1 USING DOCUMENT;
  FETCH C1 INTO SEQUENCE;
  CLOSE C1;
 END P_QUERY_XML @

/**
 * Returns in the EQUAL parameter if the two XML documents with the given
 * path are equals.
 *
 * IN DOCUMENT1
 *   First document.
 * IN PATH1
 *   xPath in the first document.
 * IN DOCUMENT2
 *   Second document.
 * IN PATH2
 *   xPatch in the second document.
 * OUT EQUAL
 *   1 if the two documents are equal according to the xPath. 0 otherwise.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE IS_XML_EQUAL (
_IF __SQLSTATE_429BB _THEN
  IN DOCUMENT1 CLOB,
_ELSE
  IN DOCUMENT1 XML,
_END
  IN PATH1 CLOB,
_IF __SQLSTATE_429BB _THEN
  IN DOCUMENT2 CLOB,
_ELSE
  IN DOCUMENT2 XML,
_END
  IN PATH2 CLOB,
  OUT EQUAL INTEGER
  )
  LANGUAGE SQL
  SPECIFIC P_IS_XML_EQUAL
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_IS_XML_EQUAL: BEGIN ATOMIC
_IF __SQLSTATE_429BB _THEN
  DECLARE SEQUENCE1 CLOB ;
  DECLARE SEQUENCE2 CLOB ;
_ELSE
  DECLARE SEQUENCE1 XML ;
  DECLARE SEQUENCE2 XML ;
_END

  IF (DOCUMENT1 IS NOT NULL AND DOCUMENT2 IS NOT NULL) THEN
   CALL QUERY_XML(DOCUMENT1, SEQUENCE1, PATH1);
   CALL QUERY_XML(DOCUMENT2, SEQUENCE2, PATH2);
   SET EQUAL = DEEP_EQUAL(SEQUENCE1, SEQUENCE2);
  END IF;
 END P_IS_XML_EQUAL @

/**
 * Returns a character representation of the given XML document.
 *
 * IN VALUE
 *   Value to convert.
 * RETURN
 *   The corresponding representation of the given XML document.
 */
ALTER MODULE DB2UNIT ADD
  FUNCTION XML_TO_CHAR(
_IF __SQLSTATE_429BB _THEN
  IN VALUE CLOB
_ELSE
  IN VALUE XML
_END
  ) RETURNS VARCHAR(500)
  LANGUAGE SQL
  SPECIFIC F_XML_TO_CHAR
  DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 F_XML_TO_CHAR: BEGIN
  DECLARE RET VARCHAR(500) DEFAULT ' ';

  IF (VALUE IS NULL) THEN
    SET RET = 'NULL';
  ELSE
-- TODO Fix the following files
_IF __SQLSTATE_429BB _THEN
   SET RET = '';
   --SET RET = TRIM(LEFT(VALUE, 500));
_ELSE
   SET RET = SUBSTR(XMLSERIALIZE(VALUE AS VARCHAR(500)), 1, 500);
_END
  END IF;
  RETURN RET;
 END F_XML_TO_CHAR @

/**
 * Asserts if the given two XML documents are the same, in null-ability and in
 * content.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN EXPECTED
 *   Expected XML document.
 * IN ACTUAL
 *   Actual XML document.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_XML_EQUALS (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
_IF __SQLSTATE_429BB _THEN
  IN EXPECTED CLOB,
  IN ACTUAL CLOB
_ELSE
  IN EXPECTED XML,
  IN ACTUAL XML
_END
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_XML_EQUALS_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_ASSERT_XML_EQUALS_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE SHOW BOOLEAN DEFAULT FALSE;
  DECLARE RET INT;
  DECLARE OUT_VAL INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'XML_EQUALS';

  CALL LOGGER.GET_LOGGER('DB2UNIT_1.DB2UNIT.ASSERT_XML_EQUALS_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, XML_TO_CHAR(EXPECTED));
  CALL LOGGER.DEBUG(LOGGER_ID, XML_TO_CHAR(ACTUAL));

  -- Check values.
  IF ((EXPECTED IS NULL AND ACTUAL IS NOT NULL)
    OR (EXPECTED IS NOT NULL AND ACTUAL IS NULL)) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'Nullability difference');
   SET SHOW = TRUE;
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_NULL_DIFF;
  ELSE
   CALL IS_XML_EQUAL(EXPECTED, NULL, ACTUAL, NULL, OUT_VAL);
   IF (OUT_VAL = 0) THEN
    CALL WRITE_IN_REPORT (ASSERT_TYPE);
    CALL WRITE_IN_REPORT (MESSAGE || 'The content of both XML documents is different');
    SET SHOW = TRUE;
    SET TEST_RESULT = RESULT_FAILED;
    SET RET = RET_DIFF_VALUE;
   END IF;
  END IF;

  -- Show problems.
  IF (SHOW = TRUE) THEN
   IF (EXPECTED IS NOT NULL) THEN
    CALL WRITE_IN_REPORT ('Expected: "' || XML_TO_CHAR(EXPECTED) || '"');
   ELSE
    CALL WRITE_IN_REPORT ('Expected: NULL');
   END IF;
   IF (ACTUAL IS NOT NULL) THEN
    CALL WRITE_IN_REPORT ('Actual  : "' || XML_TO_CHAR(ACTUAL) || '"');
   ELSE
    CALL WRITE_IN_REPORT ('Actual  : NULL');
   END IF;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_XML_EQUALS_MESSAGE @

/**
 * Asserts if the given XML document is null.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN DOC
 *   Value to check if it is null.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_XML_NULL (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
_IF __SQLSTATE_429BB _THEN
  IN DOC CLOB
_ELSE
  IN DOC XML
_END
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_XML_NULL_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_ASSERT_XML_NULL_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'XML_NULL';

  CALL LOGGER.GET_LOGGER('DB2UNIT_1.DB2UNIT.ASSERT_XML_NULL_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, XML_TO_CHAR(DOC));

  -- Check value.
  IF (DOC IS NOT NULL) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The given value is "NOT NULL"');
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_OPPOSITE_NULL;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_XML_NULL_MESSAGE @

/**
 * Asserts if the given XML document is not null.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN DOC
 *   Value to check if it is not null.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_XML_NOT_NULL (
  IN MESSAGE ANCHOR MAX_VALUES.MESSAGE_ASSERT,
_IF __SQLSTATE_429BB _THEN
  IN DOC CLOB
_ELSE
  IN DOC XML
_END
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_XML_NOT_NULL_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_ASSERT_XML_NOT_NULL_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE RET INT;
  DECLARE ASSERT_TYPE VARCHAR(16) CONSTANT 'XML_NOT_NULL';

  CALL LOGGER.GET_LOGGER('DB2UNIT_1.DB2UNIT.ASSERT_XML_NOT_NULL_MESSAGE',
    LOGGER_ID);
  CALL BEGIN_ASSERTION();

  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  SET RET = RET_OK;
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, XML_TO_CHAR(DOC));

  -- Check value.
  IF (DOC IS NULL) THEN
   CALL WRITE_IN_REPORT (ASSERT_TYPE);
   CALL WRITE_IN_REPORT (MESSAGE || 'The given value is "NULL"');
   SET TEST_RESULT = RESULT_FAILED;
   SET RET = RET_OPPOSITE_NULL;
  END IF;

  CALL END_ASSERTION();
  RETURN RET;
 END P_ASSERT_XML_NOT_NULL_MESSAGE @

