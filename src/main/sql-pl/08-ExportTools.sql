--#SET TERMINATOR @

/*
 This file is part of db2unit: A unit testing framework for Db2 LUW.
 Copyright (C)  2018  Andres Gomez Casanova (@AngocA)

 db2unit is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 db2unit is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

 Andres Gomez Casanova <angocaATyahooDOTcom>
*/

SET CURRENT SCHEMA DB2UNIT_2_BETA @

/**
 * Set of procedures to generate a Tests suite for existent suites in the 
 * database or for new tests generated from the procedure or function
 * signature.
 * When executing the generation, it does not create any extra object necessary
 * for the tests, like a table, function, etc., just the tests and test
 * fixtures.
 *
 * Version: 2018-05-23 V2_BETA
 * Author: Andres Gomez Casanova (AngocA)
 */

/**
 * Writes the content of a stored procedure in the file. This could be a test
 * or a test fixture. The character terminator is an @.
 * It opens and closes the file several times because there the flush is not
 * enough to free the buffer.
 *
 * IN DIR_ALIAS
 *   Alias of the directory where the file is generated.
 * IN FILENAME
 *   Filename of the generated file for the tests.
 * IN TEXT
 *   Content of the procedure to write in the file.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE WRITE_TEXT (
  IN DIR_ALIAS VARCHAR(128),
  IN FILENAME VARCHAR(255),
  IN TEXT ANCHOR SYSCAT.PROCEDURES.TEXT
  )
  LANGUAGE SQL
  SPECIFIC P_WRITE_TEXT
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_WRITE_TEXT: BEGIN
  DECLARE LENGTH INT;
  DECLARE INIT INT;
  DECLARE BUF_SIZE INT DEFAULT 32672; -- This should be less than maxlinesize.
  DECLARE PRE VARCHAR(32672); -- The buffer should fit in this.
  DECLARE UTL_FILE_HANDLER UTL_FILE.FILE_TYPE;

  -- In no text, then do nothing.
  IF (TEXT IS NULL) THEN
   LEAVE P_WRITE_TEXT;
  END IF;

  SET UTL_FILE_HANDLER = UTL_FILE.FOPEN(DIR_ALIAS, FILENAME, 'a', BUF_SIZE);
  SET INIT = 1;
  SET LENGTH = LENGTH(TEXT);
  WHILE (INIT < LENGTH) DO
   IF (INIT + BUF_SIZE < LENGTH) THEN
    SET PRE = SUBSTR(TEXT, INIT, BUF_SIZE);
   ELSE
    SET PRE = SUBSTR(TEXT, INIT, LENGTH - INIT + 1);
   END IF;

   CALL UTL_FILE.PUT(UTL_FILE_HANDLER, PRE);
   CALL UTL_FILE.FFLUSH(UTL_FILE_HANDLER);
   CALL UTL_FILE.FCLOSE(UTL_FILE_HANDLER);
   SET UTL_FILE_HANDLER = UTL_FILE.FOPEN(DIR_ALIAS, FILENAME, 'a', BUF_SIZE);

   SET INIT = INIT + BUF_SIZE;
  END WHILE;

  -- FIXME borrar? CALL UTL_FILE.NEW_LINE(UTL_FILE_HANDLER);
  CALL UTL_FILE.PUT_LINE(UTL_FILE_HANDLER, ' @');
  CALL UTL_FILE.NEW_LINE(UTL_FILE_HANDLER);
  CALL UTL_FILE.FFLUSH(UTL_FILE_HANDLER);
  CALL UTL_FILE.FCLOSE(UTL_FILE_HANDLER);
  END P_WRITE_TEXT @

/**
 * Generates a file with the existent test procedures for a given schema. The
 * generated file has a name with the same name of the schema with the .sql
 * extension.
 * The generated order of the test does not ensure that it works appropiately.
 * The character terminator is an @. If the generate code contains this
 * chracter, the execution of the generated file could fail.
 *
 * IN SCHEMA_NAME
 *   Name of the tests suite schema to export.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE EXTRACT_SUITE (
  IN SCHEMA_NAME ANCHOR SYSCAT.SCHEMATA.SCHEMANAME
  )
  LANGUAGE SQL
  SPECIFIC P_EXTRACT_SUITE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_EXTRACT_SUITE: BEGIN
  DECLARE DIR_ALIAS VARCHAR(128) CONSTANT 'SUITE_FILE';
  DECLARE DIRECTORY VARCHAR(1024);
  DECLARE FILENAME VARCHAR(255);
  DECLARE TEXT_VAR VARCHAR(255);
  DECLARE UTL_FILE_HANDLER UTL_FILE.FILE_TYPE;
  DECLARE IS_OPEN BOOLEAN;
  DECLARE AT_END BOOLEAN; -- End of the cursor.
  DECLARE TEST_NAME ANCHOR SYSCAT.PROCEDURES.PROCNAME;
  DECLARE TEST_CONTENT ANCHOR SYSCAT.PROCEDURES.TEXT;
  DECLARE TESTS CURSOR FOR
    SELECT PROCNAME, TEXT
    FROM SYSCAT.PROCEDURES
    WHERE PROCSCHEMA = SCHEMA_NAME
    AND PROCNAME LIKE 'TEST_%';
  DECLARE CONTINUE HANDLER FOR NOT FOUND
    SET AT_END = TRUE;

  -- FIXME This should be different according to platform
  SET DIRECTORY = '/tmp/tempo';
  SET FILENAME = 'suite_' || SCHEMA_NAME || '.sql';
  SET IS_OPEN = UTL_FILE.IS_OPEN(UTL_FILE_HANDLER);
  IF (IS_OPEN != TRUE) THEN
   CALL UTL_DIR.CREATE_OR_REPLACE_DIRECTORY(DIR_ALIAS, DIRECTORY);
   -- Creates or opens the file in writting mode (deletes content).
   SET UTL_FILE_HANDLER = UTL_FILE.FOPEN(DIR_ALIAS, FILENAME, 'w');
  END IF;
-- FIXME Reduce the utl_file calls
  CALL UTL_FILE.PUT_LINE(UTL_FILE_HANDLER, '--#SET TERMINATOR @');
  CALL UTL_FILE.NEW_LINE(UTL_FILE_HANDLER);
  CALL UTL_FILE.PUT_LINE(UTL_FILE_HANDLER, '/*');
  CALL UTL_FILE.PUT_LINE(UTL_FILE_HANDLER, ' TODO License');
  CALL UTL_FILE.PUT_LINE(UTL_FILE_HANDLER, '*/');
  CALL UTL_FILE.NEW_LINE(UTL_FILE_HANDLER);
  CALL UTL_FILE.PUT_LINE(UTL_FILE_HANDLER,
    'SET CURRENT SCHEMA DB2UNIT_EXECUTION_2 @');
  CALL UTL_FILE.NEW_LINE(UTL_FILE_HANDLER);

  CALL UTL_FILE.PUT_LINE(UTL_FILE_HANDLER, '/**');
  CALL UTL_FILE.PUT_LINE(UTL_FILE_HANDLER,
    ' * TODO Description of the tests suite.');
  CALL UTL_FILE.PUT_LINE(UTL_FILE_HANDLER, ' *');
  SELECT MAX(DEFINER) INTO TEXT_VAR
    FROM SYSCAT.PROCEDURES
    WHERE PROCSCHEMA = SCHEMA_NAME;
  CALL UTL_FILE.PUT_LINE(UTL_FILE_HANDLER, ' * Author: ' || TEXT_VAR);
  SELECT SUBSTR(MAX(CREATE_TIME), 1, 10) INTO TEXT_VAR
    FROM SYSCAT.PROCEDURES
    WHERE PROCSCHEMA = SCHEMA_NAME;
  CALL UTL_FILE.PUT_LINE(UTL_FILE_HANDLER, ' * Version: ' || TEXT_VAR);
  CALL UTL_FILE.PUT_LINE(UTL_FILE_HANDLER, ' */');
  CALL UTL_FILE.NEW_LINE(UTL_FILE_HANDLER);
  CALL UTL_FILE.PUT_LINE(UTL_FILE_HANDLER,
    'SET PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM",' || CURRENT SCHEMA
    || ', ' || SCHEMA_NAME || ' @');
  CALL UTL_FILE.NEW_LINE(UTL_FILE_HANDLER);

  CALL UTL_FILE.PUT_LINE(UTL_FILE_HANDLER, '-- Test fixtures');
  CALL UTL_FILE.FCLOSE(UTL_FILE_HANDLER);

  SELECT TEXT INTO TEST_CONTENT
    FROM SYSCAT.PROCEDURES
    WHERE PROCSCHEMA = SCHEMA_NAME
    AND PROCNAME = 'ONE_TIME_SETUP';
  CALL WRITE_TEXT(DIR_ALIAS, FILENAME, TEST_CONTENT);
  SET TEST_CONTENT = NULL;

  SELECT TEXT INTO TEST_CONTENT
    FROM SYSCAT.PROCEDURES
    WHERE PROCSCHEMA = SCHEMA_NAME
    AND PROCNAME = 'SETUP';
  CALL WRITE_TEXT(DIR_ALIAS, FILENAME, TEST_CONTENT);
  SET TEST_CONTENT = NULL;

  SELECT TEXT INTO TEST_CONTENT
    FROM SYSCAT.PROCEDURES
    WHERE PROCSCHEMA = SCHEMA_NAME
    AND PROCNAME = 'TEAR_DOWN';
  CALL WRITE_TEXT(DIR_ALIAS, FILENAME, TEST_CONTENT);
  SET TEST_CONTENT = NULL;

  SELECT TEXT INTO TEST_CONTENT
    FROM SYSCAT.PROCEDURES
    WHERE PROCSCHEMA = SCHEMA_NAME
    AND PROCNAME = 'ONE_TIME_TEAR_DOWN';
  CALL WRITE_TEXT(DIR_ALIAS, FILENAME, TEST_CONTENT);
  SET TEST_CONTENT = NULL;

  SET AT_END = FALSE;
  OPEN TESTS;
  FETCH TESTS INTO TEST_NAME, TEST_CONTENT;
  WHILE (AT_END = FALSE) DO
   SET TEST_NAME = '-- ' || TEST_NAME;

   SET UTL_FILE_HANDLER = UTL_FILE.FOPEN(DIR_ALIAS, FILENAME, 'a');
   CALL UTL_FILE.PUT_LINE(UTL_FILE_HANDLER, TEST_NAME);
   CALL UTL_FILE.NEW_LINE(UTL_FILE_HANDLER);
   CALL UTL_FILE.FCLOSE(UTL_FILE_HANDLER);

   CALL WRITE_TEXT(DIR_ALIAS, FILENAME, TEST_CONTENT);
   FETCH TESTS INTO TEST_NAME, TEST_CONTENT;
  END WHILE;

  SET UTL_FILE_HANDLER = UTL_FILE.FOPEN(DIR_ALIAS, FILENAME, 'a');
  CALL UTL_FILE.PUT_LINE(UTL_FILE_HANDLER,
    '-- Register the suite.');
  CALL UTL_FILE.PUT_LINE(UTL_FILE_HANDLER,
    'CALL DB2UNIT.REGISTER_SUITE(CURRENT SCHEMA) @');
  CALL UTL_FILE.NEW_LINE(UTL_FILE_HANDLER);
  CALL UTL_FILE.FFLUSH(UTL_FILE_HANDLER);
  CALL UTL_FILE.FCLOSE(UTL_FILE_HANDLER);
 END P_EXTRACT_SUITE @

/**
 * Generates the header of a file.
 *
 * IN SCHEMA
 *   Schema of the current test.
 * RETURNS the string that describes the header.
 */
ALTER MODULE DB2UNIT ADD
  FUNCTION GET_HEADER_PROC_FILE_TEST (
  IN SCHEMA ANCHOR SYSCAT.SCHEMATA.SCHEMANAME
  ) RETURNS VARCHAR(10000)
  LANGUAGE SQL
  PARAMETER CCSID UNICODE
  SPECIFIC F_GET_HEADER_PROC_FILE_TEST
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  READS SQL DATA
 F_GET_HEADER_PROC_FILE_TEST: BEGIN
  DECLARE RET VARCHAR(10000);

  SET RET = '--#SET TERMINATOR @\n';
  SET RET = RET || '\n';
  SET RET = RET || '/*\n';
  SET RET = RET || ' TODO License\n';
  SET RET = RET || '*/\n';
  SET RET = RET || '\n';
  SET RET = RET || 'SET CURRENT SCHEMA ' || SCHEMA || ' @\n';
  SET RET = RET || '\n';
  SET RET = RET || '/**\n';
  SET RET = RET || ' * TODO Description of the tests suite.\n';
  SET RET = RET || ' *\n';
  SET RET = RET || ' * Author: TODO\n';
  SET RET = RET || ' * Version: TODO\n';
  SET RET = RET || ' */\n';
  SET RET = RET || '\n';
  SET RET = RET || 'SET PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM",'
    || SCHEMA || ' @\n';
  SET RET = RET || '\n';
  SET RET = RET || '-- Test fixtures\n';
  SET RET = RET || 'CREATE OR REPLACE PROCEDURE ONE_TIME_SETUP()\n';
  SET RET = RET || ' P_ONE_TIME_SETUP: BEGIN\n';
  SET RET = RET || '  -- TODO Your code\n';
  SET RET = RET || ' END P_ONE_TIME_SETUP\n';
  SET RET = RET || ' @\n';
  SET RET = RET || '\n';
  SET RET = RET || 'CREATE OR REPLACE PROCEDURE SETUP()\n';
  SET RET = RET || ' P_SETUP: BEGIN\n';
  SET RET = RET || '  -- TODO Your code\n';
  SET RET = RET || ' END P_SETUP\n';
  SET RET = RET || ' @\n';
  SET RET = RET || '\n';
  SET RET = RET || 'CREATE OR REPLACE PROCEDURE TEAR_DOWN()\n';
  SET RET = RET || ' P_TEAR_DOWN: BEGIN\n';
  SET RET = RET || '  -- TODO Your code\n';
  SET RET = RET || ' END P_TEAR_DOWN\n';
  SET RET = RET || ' @\n';
  SET RET = RET || '\n';
  SET RET = RET || 'CREATE OR REPLACE PROCEDURE ONE_TIME_TEAR_DOWN()\n';
  SET RET = RET || ' P_ONE_TIME_TEAR_DOWN: BEGIN\n';
  SET RET = RET || '  -- TODO Your code\n';
  SET RET = RET || ' END P_ONE_TIME_TEAR_DOWN\n';
  SET RET = RET || ' @\n';
  SET RET = RET || '\n';

  RETURN RET;
 END F_GET_HEADER_PROC_FILE_TEST @

/**
 * Generates the header and the definition of the variables of a procedure.
 *
 * IN SCHEMA
 *   Schema of the current test.
 * IN MODULE_NAME
 *   Name of the module where the procedure resides. This could be null if the
 *   procedure is not inside a module.
 * IN PROC_NAME
 *   Name of the procedure to generate the basic tests.
 * RETURNS the string that contains the header and variables.
 */
ALTER MODULE DB2UNIT ADD
  FUNCTION GET_HEADER_PROC_TEST (
  IN SCHEMA_NAME ANCHOR SYSCAT.SCHEMATA.SCHEMANAME,
  IN MODULE_NAME ANCHOR SYSCAT.MODULES.MODULENAME DEFAULT NULL,
  IN PROC_NAME ANCHOR SYSCAT.PROCEDURES.PROCNAME
  ) RETURNS VARCHAR(10000)
  LANGUAGE SQL
  PARAMETER CCSID UNICODE
  SPECIFIC F_GET_HEADER_PROC_TEST
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  READS SQL DATA
 F_GET_HEADER_PROC_TEST: BEGIN
  DECLARE TYPESCHEMA ANCHOR SYSCAT.ROUTINEPARMS.TYPESCHEMA;
  DECLARE TYPENAME ANCHOR SYSCAT.ROUTINEPARMS.TYPENAME;
  DECLARE PARMNAME ANCHOR SYSCAT.ROUTINEPARMS.PARMNAME;
  DECLARE LENGTH ANCHOR SYSCAT.ROUTINEPARMS.LENGTH;
  DECLARE SCALE ANCHOR SYSCAT.ROUTINEPARMS.SCALE;
  DECLARE ROWTYPE ANCHOR SYSCAT.ROUTINEPARMS.ROWTYPE;
  DECLARE RET VARCHAR(10000);
  DECLARE AT_END BOOLEAN; -- End of the cursor.
  -- ROWTYPE = B Both input output, O Output, P Input.
  -- ORDINAL = Position of the parameter in the signature.
  -- LENGHT = Lenght of the data type.
  -- SCALE = Number of digits.
  DECLARE PARAMS_CURSOR CURSOR FOR
   SELECT P.TYPESCHEMA, P.TYPENAME, P.PARMNAME, P.LENGTH, P.SCALE, P.ROWTYPE
   FROM SYSCAT.ROUTINEPARMS P
    JOIN SYSCAT.ROUTINES R
    ON (P.ROUTINESCHEMA = R.ROUTINESCHEMA
     AND P.ROUTINEMODULENAME = R.ROUTINEMODULENAME
     AND P.ROUTINENAME = R.ROUTINENAME)
   WHERE P.ROUTINESCHEMA = SCHEMA_NAME
    AND P.ROUTINEMODULENAME = MODULE_NAME
    AND P.ROUTINENAME = PROC_NAME
    AND P.ROWTYPE IN ('P', 'O', 'B')
    AND R.ROUTINETYPE = 'P'
   ORDER BY P.ORDINAL;
  DECLARE CONTINUE HANDLER FOR NOT FOUND
    SET AT_END = TRUE;

  SET RET = '';
  SET RET = RET || '-- TODO Copy this procedure as many times as necessary for '
    || 'the different tests.\n';
  SET RET = RET || '-- Make sure the name is different for each test.\n';
  SET RET = RET || '/**\n';
  SET RET = RET || ' * TODO Describe this test.\n';
  SET RET = RET || ' */\n';
  SET RET = RET || 'CREATE OR REPLACE PROCEDURE TEST_' || PROC_NAME || '()\n';
  SET RET = RET || ' BEGIN\n';
  SET RET = RET || '  -- TODO Assign an appropriate value for the variables.\n';

  SET AT_END = FALSE;
  OPEN PARAMS_CURSOR;
  FETCH PARAMS_CURSOR INTO TYPESCHEMA, TYPENAME, PARMNAME, LENGTH, SCALE,
    ROWTYPE;
  WHILE (AT_END = FALSE) DO
   CASE
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'BOOLEAN'
      AND ROWTYPE = 'P' THEN
     SET RET = RET || '  DECLARE ' || PARMNAME || ' BOOLEAN;\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'BOOLEAN'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || '  DECLARE EXPECTED_' || PARMNAME || ' BOOLEAN;\n';
     SET RET = RET || '  DECLARE ACTUAL_' || PARMNAME || ' BOOLEAN;\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'TIMESTAMP'
      AND ROWTYPE = 'P' THEN
     SET RET = RET || '  DECLARE ' || PARMNAME || ' TIMESTAMP;\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'TIMESTAMP'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || '  DECLARE EXPECTED_' || PARMNAME || ' TIMESTAMP;\n';
     SET RET = RET || '  DECLARE ACTUAL_' || PARMNAME || ' TIMESTAMP;\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'DATE' AND ROWTYPE = 'P' THEN
     SET RET = RET || '  DECLARE ' || PARMNAME || ' DATE;\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'DATE'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || '  DECLARE EXPECTED_' || PARMNAME || ' DATE;\n';
     SET RET = RET || '  DECLARE ACTUAL_' || PARMNAME || ' DATE;\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'TIME' AND ROWTYPE = 'P' THEN
     SET RET = RET || '  DECLARE ' || PARMNAME || ' TIME;\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'TIME'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || '  DECLARE EXPECTED_' || PARMNAME || ' TIME;\n';
     SET RET = RET || '  DECLARE ACTUAL_' || PARMNAME || ' TIME;\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'DECIMAL' AND ROWTYPE = 'P' THEN
     SET RET = RET || '  DECLARE ' || PARMNAME || ' DECIMAL(' || LENGTH || ','
       || SCALE || ');\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'DECIMAL'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || '  DECLARE EXPECTED_' || PARMNAME || ' DECIMAL('
       || LENGTH || ',' || SCALE || ');\n';
     SET RET = RET || '  DECLARE ACTUAL_' || PARMNAME || ' DECIMAL(' || LENGTH
       || ',' || SCALE || ');\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'DOUBLE' AND ROWTYPE = 'P' THEN
     SET RET = RET || '  DECLARE ' || PARMNAME || ' DOUBLE;\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'DOUBLE'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || '  DECLARE EXPECTED_' || PARMNAME || ' DOUBLE;\n';
     SET RET = RET || '  DECLARE ACTUAL_' || PARMNAME || ' DOUBLE;\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'FLOAT' AND ROWTYPE = 'P' THEN
     SET RET = RET || '  DECLARE ' || PARMNAME || ' FLOAT(' || LENGTH
       || ');\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'FLOAT'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || '  DECLARE EXPECTED_' || PARMNAME || ' FLOAT(' || LENGTH
       || ');\n';
     SET RET = RET || '  DECLARE ACTUAL_' || PARMNAME || ' FLOAT(' || LENGTH
       || ');\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'DECFLOAT' AND ROWTYPE = 'P' THEN
     SET RET = RET || '  DECLARE ' || PARMNAME || ' DECFLOAT;\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'DECFLOAT'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || '  DECLARE EXPECTED_' || PARMNAME || ' DECFLOAT;\n';
     SET RET = RET || '  DECLARE ACTUAL_' || PARMNAME || ' DECFLOAT;\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'REAL' AND ROWTYPE = 'P' THEN
     SET RET = RET || '  DECLARE ' || PARMNAME || ' REAL;\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'REAL'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || '  DECLARE EXPECTED_' || PARMNAME || ' REAL;\n';
     SET RET = RET || '  DECLARE ACTUAL_' || PARMNAME || ' REAL;\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'SMALLINT' AND ROWTYPE = 'P' THEN
     SET RET = RET || '  DECLARE ' || PARMNAME || ' SMALLINT;\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'SMALLINT'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || '  DECLARE EXPECTED_' || PARMNAME || ' SMALLINT;\n';
     SET RET = RET || '  DECLARE ACTUAL_' || PARMNAME || ' SMALLINT;\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'INTEGER' AND ROWTYPE = 'P' THEN
     SET RET = RET || '  DECLARE ' || PARMNAME || ' INTEGER;\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'INTEGER'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || '  DECLARE EXPECTED_' || PARMNAME || ' INTEGER;\n';
     SET RET = RET || '  DECLARE ACTUAL_' || PARMNAME || ' INTEGER;\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'BIGINT' AND ROWTYPE = 'P' THEN
     SET RET = RET || '  DECLARE ' || PARMNAME || ' BIGINT;\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'BIGINT'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || '  DECLARE EXPECTED_' || PARMNAME || ' BIGINT;\n';
     SET RET = RET || '  DECLARE ACTUAL_' || PARMNAME || ' BIGINT;\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'CHARACTER' AND ROWTYPE = 'P' THEN
     SET RET = RET || '  DECLARE ' || PARMNAME || ' CHARACTER(' || LENGTH
       || ');\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'CHARACTER'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || '  DECLARE EXPECTED_' || PARMNAME || ' CHARACTER('
       || LENGTH || ');\n';
     SET RET = RET || '  DECLARE ACTUAL_' || PARMNAME || ' CHARACTER('
       || LENGTH || ');\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'VARCHAR' AND ROWTYPE = 'P' THEN
     SET RET = RET || '  DECLARE ' || PARMNAME || ' VARCHAR(' || LENGTH
       || ');\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'VARCHAR'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || '  DECLARE EXPECTED_' || PARMNAME || ' VARCHAR('
       || LENGTH || ');\n';
     SET RET = RET || '  DECLARE ACTUAL_' || PARMNAME || ' VARCHAR(' || LENGTH
       || ');\n';
    ELSE
     -- Unknown type
     SET RET = RET || '  -- TODO This is an unknown type, and db2unit has not '
       || 'assertions for it.\n';
     -- When there is an unknown type, but you know how to assert it, please
     -- modify the code here.
    END CASE;

   FETCH PARAMS_CURSOR INTO TYPESCHEMA, TYPENAME, PARMNAME, LENGTH, SCALE,
     ROWTYPE;
  END WHILE;

  SET RET = RET || '\n';
  SET RET = RET
    || '  -- TODO Delete if the procedure does not raise any exception.\n';
  SET RET = RET || '  DECLARE CONTINUE HANDLER FOR SQLSTATE ''99999''\n';
  SET RET = RET || '    BEGIN\n';
  SET RET = RET || '     -- TODO What to do in case of an exception.\n';
  SET RET = RET
    || '     CALL DB2UNIT.FAIL(''TODO Put a message about why it failed'');\n';
  SET RET = RET || '    END;\n';
  SET RET = RET || '\n';
  SET RET = RET
    || '  CALL DB2UNIT.REGISTER_MESSAGE(''TODO Put a description.'');\n';
  SET RET = RET || '\n';

  RETURN RET;
 END F_GET_HEADER_PROC_TEST @

 /**
 * Generates the header and the definition of the variables of a procedure.
 *
 * IN SCHEMA_NAME
 *   Schema of the current test.
 * IN MODULE_NAME
 *   Name of the module where the procedure resides. This could be null if the
 *   procedure is not inside a module.
 * IN PROC_NAME
 *   Name of the procedure to generate the basic tests.
 * RETURNS the string that contains the header and variables.
 */
ALTER MODULE DB2UNIT ADD
  FUNCTION GET_PROC_SIGNATURE (
  IN SCHEMA_NAME ANCHOR SYSCAT.SCHEMATA.SCHEMANAME,
  IN MODULE_NAME ANCHOR SYSCAT.MODULES.MODULENAME DEFAULT NULL,
  IN PROC_NAME ANCHOR SYSCAT.PROCEDURES.PROCNAME
  ) RETURNS VARCHAR(10000)
  LANGUAGE SQL
  PARAMETER CCSID UNICODE
  SPECIFIC F_GET_PROC_SIGNATURE
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  READS SQL DATA
 F_GET_PROC_SIGNATURE: BEGIN
  DECLARE TYPESCHEMA ANCHOR SYSCAT.ROUTINEPARMS.TYPESCHEMA;
  DECLARE TYPENAME ANCHOR SYSCAT.ROUTINEPARMS.TYPENAME;
  DECLARE PARMNAME ANCHOR SYSCAT.ROUTINEPARMS.PARMNAME;
  DECLARE ROWTYPE ANCHOR SYSCAT.ROUTINEPARMS.ROWTYPE;
  DECLARE RET VARCHAR(10000);
  DECLARE AT_END BOOLEAN; -- End of the cursor.
  DECLARE PARAMS_CURSOR CURSOR FOR
   SELECT P.TYPESCHEMA, P.TYPENAME, P.PARMNAME, P.ROWTYPE
   FROM SYSCAT.ROUTINEPARMS P
    JOIN SYSCAT.ROUTINES R
    ON (P.ROUTINESCHEMA = R.ROUTINESCHEMA
     AND P.ROUTINEMODULENAME = R.ROUTINEMODULENAME
     AND P.ROUTINENAME = R.ROUTINENAME)
   WHERE P.ROUTINESCHEMA = SCHEMA_NAME
   AND P.ROUTINEMODULENAME = MODULE_NAME
   AND P.ROUTINENAME = PROC_NAME
   AND P.ROWTYPE IN ('O', 'B', 'P')
   AND R.ROUTINETYPE = 'P'
   ORDER BY P.ORDINAL;
  DECLARE CONTINUE HANDLER FOR NOT FOUND
    SET AT_END = TRUE;

  SET RET = '';
  SET AT_END = FALSE;
  OPEN PARAMS_CURSOR;
  FETCH PARAMS_CURSOR INTO TYPESCHEMA, TYPENAME, PARMNAME, ROWTYPE;
  WHILE (AT_END = FALSE) DO
   CASE
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'BOOLEAN' AND ROWTYPE = 'P' THEN
     SET RET = RET || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'BOOLEAN'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || 'ACTUAL_' || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'TIMESTAMP'
      AND ROWTYPE = 'P' THEN
     SET RET = RET || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'TIMESTAMP'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || 'ACTUAL_' || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'DATE' AND ROWTYPE = 'P' THEN
     SET RET = RET || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'DATE'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || 'ACTUAL_' || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'TIME' AND ROWTYPE = 'P' THEN
     SET RET = RET || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'TIME'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || 'ACTUAL_' || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'DECIMAL' AND ROWTYPE = 'P' THEN
     SET RET = RET || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'DECIMAL'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || 'ACTUAL_' || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'DOUBLE' AND ROWTYPE = 'P' THEN
     SET RET = RET || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'DOUBLE'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || 'ACTUAL_' || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'FLOAT' AND ROWTYPE = 'P' THEN
     SET RET = RET || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'FLOAT'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || 'ACTUAL_' || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'DECFLOAT' AND ROWTYPE = 'P' THEN
     SET RET = RET || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'DECFLOAT'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || 'ACTUAL_' || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'REAL' AND ROWTYPE = 'P' THEN
     SET RET = RET || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'REAL'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || 'ACTUAL_' || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'SMALLINT' AND ROWTYPE = 'P' THEN
     SET RET = RET || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'SMALLINT'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || 'ACTUAL_' || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'INTEGER' AND ROWTYPE = 'P' THEN
     SET RET = RET || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'INTEGER'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || 'ACTUAL_' || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'BIGINT' AND ROWTYPE = 'P' THEN
     SET RET = RET || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'BIGINT'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || 'ACTUAL_' || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'CHARACTER' AND ROWTYPE = 'P' THEN
     SET RET = RET || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'CHARACTER'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || 'ACTUAL_' || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'VARCHAR' AND ROWTYPE = 'P' THEN
     SET RET = RET || PARMNAME || ', ';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'VARCHAR'
      AND ROWTYPE IN ('O', 'B') THEN
     SET RET = RET || 'ACTUAL_' || PARMNAME || ', ';
    ELSE
     -- Unknown type
     SET RET = RET || '  -- TODO This is an unknown type, and db2unit has not '
       || 'assertions for it.\n';
     -- When there is an unknown type, but you know how to assert it, please
     -- modify the code here.
    END CASE;

   FETCH PARAMS_CURSOR INTO TYPESCHEMA, TYPENAME, PARMNAME, ROWTYPE;
  END WHILE;

  -- Removes the extra comma.
  IF (LENGTH(RET) > 2) THEN
   SET RET = SUBSTR(RET, 1, LENGTH(RET) - 2);
  END IF;

  RETURN RET;
 END F_GET_PROC_SIGNATURE @

/**
 * Generates the asserts of the output parameters of a procedure and closes the
 * test.
 *
 * IN SCHEMA_NAME
 *   Schema of the current test.
 * IN MODULE_NAME
 *   Name of the module where the procedure resides. This could be null if the
 *   procedure is not inside a module.
 * IN PROC_NAME
 *   Name of the procedure to generate the basic tests.
 * RETURNS the string that contains the asserts of the output parameters.
 */
ALTER MODULE DB2UNIT ADD
  FUNCTION GET_ASSERTS_TAIL_PROC_TEST (
  IN SCHEMA_NAME ANCHOR SYSCAT.SCHEMATA.SCHEMANAME,
  IN MODULE_NAME ANCHOR SYSCAT.MODULES.MODULENAME DEFAULT NULL,
  IN PROC_NAME ANCHOR SYSCAT.PROCEDURES.PROCNAME
  ) RETURNS VARCHAR(10000)
  LANGUAGE SQL
  PARAMETER CCSID UNICODE
  SPECIFIC F_GET_ASSERTS_TAIL_PROC_TEST
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  READS SQL DATA
 F_GET_ASSERTS_TAIL_PROC_TEST: BEGIN
  DECLARE TYPESCHEMA ANCHOR SYSCAT.ROUTINEPARMS.TYPESCHEMA;
  DECLARE TYPENAME ANCHOR SYSCAT.ROUTINEPARMS.TYPENAME;
  DECLARE PARMNAME ANCHOR SYSCAT.ROUTINEPARMS.PARMNAME;
  DECLARE RET VARCHAR(10000);
  DECLARE AT_END BOOLEAN; -- End of the cursor.
  DECLARE PARAMS_CURSOR CURSOR FOR
   SELECT P.TYPESCHEMA, P.TYPENAME, P.PARMNAME
   FROM SYSCAT.ROUTINEPARMS P
    JOIN SYSCAT.ROUTINES R
    ON (P.ROUTINESCHEMA = R.ROUTINESCHEMA
     AND P.ROUTINEMODULENAME = R.ROUTINEMODULENAME
     AND P.ROUTINENAME = R.ROUTINENAME)
   WHERE P.ROUTINESCHEMA = SCHEMA_NAME
   AND P.ROUTINEMODULENAME = MODULE_NAME
   AND P.ROUTINENAME = PROC_NAME
   AND P.ROWTYPE in ('B', 'O')
   AND R.ROUTINETYPE = 'P'
   ORDER BY P.ORDINAL;
  DECLARE CONTINUE HANDLER FOR NOT FOUND
    SET AT_END = TRUE;

  SET RET = '';
  SET RET = RET || '  -- TODO Delete the unnecessary assertions, if any.\n';
  SET AT_END = FALSE;
  OPEN PARAMS_CURSOR;
  FETCH PARAMS_CURSOR INTO TYPESCHEMA, TYPENAME, PARMNAME;
  WHILE (AT_END = FALSE) DO
   SET RET = RET || '\n';
   CASE
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'BOOLEAN' THEN
     SET RET = RET || '  CALL DB2UNIT.ASSERT_BOOLEAN_EQUALS (''TODO Message'', '
       || 'EXPECTED_' || PARMNAME || ', ACTUAL_' || PARMNAME || ');\n';
     SET RET = RET || '  CALL DB2UNIT.ASSERT_BOOLEAN_TRUE (''TODO Message'', '
       || 'ACTUAL_' || PARMNAME || ');\n';
     SET RET = RET || '  CALL DB2UNIT.ASSERT_BOOLEAN_FALSE (''TODO Message'', '
       || 'ACTUAL_' || PARMNAME || ');\n';
     SET RET = RET || '  CALL DB2UNIT.ASSERT_BOOLEAN_NULL (''TODO Message'', '
       || 'ACTUAL_' || PARMNAME || ');\n';
     SET RET = RET
       || '  CALL DB2UNIT.ASSERT_BOOLEAN_NOT_NULL (''TODO Message'', ACTUAL_'
	   || PARMNAME || ');\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'TIMESTAMP' THEN
     SET RET = RET || '  CALL DB2UNIT.ASSERT_TIMESTAMP_EQUALS (''TODO '
       || 'Message'', EXPECTED_' || PARMNAME || ', ACTUAL_' || PARMNAME
	   || ');\n';
     SET RET = RET || '  CALL DB2UNIT.ASSERT_TIMESTAMP_NULL (''TODO '
       || 'Message'', ACTUAL_' || PARMNAME || ');\n';
     SET RET = RET || '  CALL DB2UNIT.ASSERT_TIMESTAMP_NOT_NULL (''TODO '
       || 'Message'', ACTUAL_' || PARMNAME || ');\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'DATE' THEN
     SET RET = RET || '  CALL DB2UNIT.ASSERT_DATE_EQUALS (''TODO Message'', '
       || 'EXPECTED_' || PARMNAME || ', ACTUAL_' || PARMNAME || ');\n';
     SET RET = RET || '  CALL DB2UNIT.ASSERT_DATE_NULL (''TODO Message'', '
       || 'ACTUAL_' || PARMNAME || ');\n';
     SET RET = RET || '  CALL DB2UNIT.ASSERT_DATE_NOT_NULL (''TODO Message'', '
       || 'ACTUAL_' || PARMNAME || ');\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND TYPENAME = 'TIME' THEN
     SET RET = RET || '  CALL DB2UNIT.ASSERT_TIME_EQUALS (''TODO Message'', '
       || 'EXPECTED_' || PARMNAME || ', ACTUAL_' || PARMNAME || ');\n';
     SET RET = RET || '  CALL DB2UNIT.ASSERT_TIME_NULL (''TODO Message'', '
       || 'ACTUAL_' || PARMNAME || ');\n';
     SET RET = RET || '  CALL DB2UNIT.ASSERT_TIME_NOT_NULL (''TODO Message'', '
       || 'ACTUAL_' || PARMNAME || ');\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND (TYPENAME = 'DECIMAL' OR TYPENAME = 'DOUBLE'
      OR TYPENAME = 'FLOAT' OR TYPENAME = 'DECFLOAT' OR TYPENAME = 'REAL') THEN
     SET RET = RET || '  CALL DB2UNIT.ASSERT_DEC_EQUALS (''TODO Message'', '
       || 'EXPECTED_' || PARMNAME || ', ACTUAL_' || PARMNAME || ');\n';
     SET RET = RET || '  CALL DB2UNIT.ASSERT_DEC_NULL (''TODO Message'', '
       || 'ACTUAL_' || PARMNAME || ');\n';
     SET RET = RET || '  CALL DB2UNIT.ASSERT_DEC_NOT_NULL (''TODO Message'', '
       || 'ACTUAL_' || PARMNAME || ');\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND (TYPENAME = 'SMALLINT'
      OR TYPENAME = 'INTEGER' OR TYPENAME = 'BIGINT') THEN
     SET RET = RET || '  CALL DB2UNIT.ASSERT_INT_EQUALS (''TODO Message'', '
       || 'EXPECTED_' || PARMNAME || ', ACTUAL_' || PARMNAME || ');\n';
     SET RET = RET || '  CALL DB2UNIT.ASSERT_INT_NULL (''TODO Message'', '
       || 'ACTUAL_' || PARMNAME || ');\n';
     SET RET = RET || '  CALL DB2UNIT.ASSERT_INT_NOT_NULL (''TODO Message'', '
       || 'ACTUAL_' || PARMNAME || ');\n';
    WHEN TYPESCHEMA = 'SYSIBM' AND (TYPENAME = 'CHARACTER'
      OR TYPENAME = 'VARCHAR') THEN
     SET RET = RET || '  CALL DB2UNIT.ASSERT_STRING_EQUALS (''TODO Message'', '
       || 'EXPECTED_' || PARMNAME || ', ACTUAL_' || PARMNAME || ');\n';
     SET RET = RET || '  CALL DB2UNIT.ASSERT_STRING_NULL (''TODO Message'', '
       || 'ACTUAL_' || PARMNAME || ');\n';
     SET RET = RET || '  CALL DB2UNIT.ASSERT_STRING_NOT_NULL (''TODO '
       || 'Message'', ACTUAL_' || PARMNAME || ');\n';
    ELSE
     -- Unknown type
     SET RET = RET || '  -- TODO This is an unknown type, and db2unit has not '
       || 'assertions for it.\n';
     -- When there is an unknown type, but you know how to assert it, please
     -- modify the code here.
    END CASE;

   FETCH PARAMS_CURSOR INTO TYPESCHEMA, TYPENAME, PARMNAME;
  END WHILE;
  SET RET = RET || '\n';
  SET RET = RET || '  -- TODO If the procedure should fail in this part.\n';
  SET RET = RET
    || '  CALL DB2UNIT.FAIL(''TODO Put a message about why it failed'');\n';
  SET RET = RET || ' END\n';
  SET RET = RET || ' @\n';
  SET RET = RET || '\n';

  RETURN RET;
 END F_GET_ASSERTS_TAIL_PROC_TEST @

/**
 * Generates a file with a set of possible tests for the given procedure. The
 * generated file has a name with the same name of the schema with the .sql
 * extension.
 *
 * IN SCHEMA_NAME
 *   Name of the schema where the procedure resides.
 * IN MODULE_NAME
 *   Name of the module where the procedure resides. This could be null if the
 *   procedure is not inside a module.
 * IN PROC_NAME
 *   Name of the procedure to generate the basic tests.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE GENERATE_TESTS_PROCEDURE(
  IN SCHEMA_NAME ANCHOR SYSCAT.SCHEMATA.SCHEMANAME,
  IN MODULE_NAME ANCHOR SYSCAT.MODULES.MODULENAME DEFAULT NULL,
  IN PROC_NAME ANCHOR SYSCAT.PROCEDURES.PROCNAME
  )
  LANGUAGE SQL
  SPECIFIC P_GENERATE_TESTS_PROCEDURE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_GENERATE_TESTS_PROCEDURE: BEGIN
  DECLARE BUFFER VARCHAR(32672);
  DECLARE DIRECTORY VARCHAR(1024);
  DECLARE FILENAME VARCHAR(255);
  DECLARE DIR_ALIAS VARCHAR(128) CONSTANT 'LOG_FILE';
  DECLARE IS_OPEN BOOLEAN;
  DECLARE UTL_FILE_HANDLER UTL_FILE.FILE_TYPE;
  DECLARE BUF_SIZE INT DEFAULT 32672; -- This should be less than maxlinesize.
 
  -- Creates the directory and opens the file descriptor.
  SET DIRECTORY = '/tmp/tempo'; -- FIXME cambiar
  SET FILENAME = SCHEMA_NAME || '-';
  IF (MODULE_NAME IS NOT NULL) THEN
   SET FILENAME = FILENAME || MODULE_NAME || '-';
  END IF;
  SET FILENAME = FILENAME || PROC_NAME;
  SET IS_OPEN = UTL_FILE.IS_OPEN(UTL_FILE_HANDLER);
  IF (IS_OPEN != TRUE) THEN
   CALL UTL_DIR.CREATE_OR_REPLACE_DIRECTORY(DIR_ALIAS, DIRECTORY);
   SET UTL_FILE_HANDLER = UTL_FILE.FOPEN(DIR_ALIAS, FILENAME, 'w', BUF_SIZE);
  END IF;
-- FIXME Reduce the utl_file calls
-- FIXME Convert \n into carriage returns
  -- Gets the header of the file.
  SET BUFFER = GET_HEADER_PROC_FILE_TEST(SCHEMA_NAME);
  CALL UTL_FILE.PUT(UTL_FILE_HANDLER, BUFFER);
  CALL UTL_FILE.FFLUSH(UTL_FILE_HANDLER);

  SET BUFFER = GET_HEADER_PROC_TEST(SCHEMA_NAME, MODULE_NAME, PROC_NAME);
  CALL UTL_FILE.PUT(UTL_FILE_HANDLER, BUFFER);
  CALL UTL_FILE.FFLUSH(UTL_FILE_HANDLER);

  SET BUFFER = '  CALL ' || SCHEMA_NAME || '.';
  IF (MODULE_NAME IS NOT NULL) THEN
   SET BUFFER = BUFFER || MODULE_NAME || '.';
  END IF;
  SET BUFFER = BUFFER || PROC_NAME || ' (' || GET_PROC_SIGNATURE(SCHEMA_NAME,
    MODULE_NAME, PROC_NAME) || ');\n';
  SET BUFFER = BUFFER || '\n';
  CALL UTL_FILE.PUT(UTL_FILE_HANDLER, BUFFER);
  CALL UTL_FILE.FFLUSH(UTL_FILE_HANDLER);

  SET BUFFER = GET_ASSERTS_TAIL_PROC_TEST(SCHEMA_NAME, MODULE_NAME,
    PROC_NAME);
  CALL UTL_FILE.PUT(UTL_FILE_HANDLER, BUFFER);
  CALL UTL_FILE.FFLUSH(UTL_FILE_HANDLER);

  SET BUFFER = '-- Register the suite.\n';
  SET BUFFER = BUFFER || 'CALL DB2UNIT.REGISTER_SUITE(CURRENT SCHEMA) @\n';
  SET BUFFER = BUFFER || '\n';
  CALL UTL_FILE.PUT(UTL_FILE_HANDLER, BUFFER);
  CALL UTL_FILE.FFLUSH(UTL_FILE_HANDLER);

  CALL UTL_FILE.FCLOSE(UTL_FILE_HANDLER);

 END P_GENERATE_TESTS_PROCEDURE @

 /**
 * Generates a file with a set of possible tests for the given function. The
 * generated file has a name with the same name of the schema with the .sql
 * extension.
 *
 * IN SCHEMA_NAME
 *   Name of the schema where the function resides.
 * IN MODULE_NAME
 *   Name of the module where the funcion resides. This could be null if the
 *   function is not inside a module.
 * IN FUNC_NAME
 *   Name of the function to generate the basic tests.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE GENERATE_TESTS_FUNCTION (
  IN SCHEMA_NAME ANCHOR SYSCAT.SCHEMATA.SCHEMANAME,
  IN MODULE_NAME ANCHOR SYSCAT.MODULES.MODULENAME DEFAULT NULL,
  IN FUNC_NAME ANCHOR SYSCAT.FUNCTIONS.FUNCNAME
  )
  LANGUAGE SQL
  SPECIFIC P_GENERATE_TESTS_FUNCTION
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_GENERATE_TESTS_FUNCTION: BEGIN
 -- TODO
 END P_GENERATE_TESTS_FUNCTION @
